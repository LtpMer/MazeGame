<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Maze Game with Save & Leaderboard</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #eee;
    margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center;
  }
  canvas {
    border: 2px solid #333;
    background: white;
    margin: 10px 0;
  }
  #controls {
    display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 10px;
  }
  button {
    padding: 8px 14px;
    cursor: pointer;
    font-weight: bold;
  }
  #buildControls, #typesControls {
    margin-top: 10px;
  }
  #leaderboard {
    background: white;
    border: 1px solid #ccc;
    max-width: 400px;
    padding: 10px;
    margin-top: 20px;
    font-size: 14px;
  }
  #leaderboard h3 {
    margin-top: 0;
  }
  #leaderboard table {
    width: 100%;
    border-collapse: collapse;
  }
  #leaderboard th, #leaderboard td {
    border: 1px solid #ccc;
    padding: 4px;
    text-align: left;
  }
  #leaderboard .admin {
    color: red;
    font-weight: bold;
  }
  #loginForm {
    background: white;
    padding: 15px;
    margin-bottom: 10px;
    border: 1px solid #aaa;
    width: 320px;
    box-sizing: border-box;
  }
  #loginForm input {
    padding: 6px;
    margin: 5px 0;
    width: 100%;
    box-sizing: border-box;
  }
  #saveSlots button {
    margin-right: 6px;
  }
</style>
</head>
<body>

<h1>Maze Game with Save & Leaderboard</h1>

<div id="loginForm">
  <h3>Login or Register</h3>
  <input type="text" id="usernameInput" placeholder="Username" autocomplete="off" />
  <input type="password" id="passwordInput" placeholder="Password" autocomplete="off" />
  <button id="loginBtn">Login/Register</button>
  <p id="loginMsg" style="color:red; font-weight:bold;"></p>
</div>

<div id="userInfo" style="display:none;">
  Logged in as <span id="currentUser"></span> <button id="logoutBtn">Logout</button>
</div>

<div id="controls" style="display:none;">
  <button id="toggleBuildBtn">Toggle Build Mode</button>
  <button id="clearBtn">Clear Maze</button>
  
  <div id="saveSlots">
    <button data-slot="1">Save Slot 1</button>
    <button data-slot="2">Save Slot 2</button>
    <button data-slot="3">Save Slot 3</button>
  </div>
  
  <div id="buildControls" style="display:none;">
    <button id="drawBtn" class="active">Draw Block</button>
    <button id="deleteBtn">Delete Block</button>
  </div>
  
  <div id="typesControls" style="display:none; margin-top:10px;">
    <button data-type="wall" class="active">Wall</button>
    <button data-type="design">Design</button>
    <button data-type="movable">Movable</button>
    <button data-type="player">Player</button>
    <button data-type="win">Win</button>
  </div>
  <button id="toggleTypesBtn">Toggle Types</button>
</div>

<canvas id="gameCanvas" width="600" height="600"></canvas>

<div id="stats" style="max-width:400px;">
  <h3>Win Stats</h3>
  <div id="statsDisplay"></div>
</div>

<div id="leaderboard">
  <h3>Leaderboard</h3>
  <table>
    <thead><tr><th>Username</th><th>Wins</th><th>Password</th></tr></thead>
    <tbody id="leaderboardBody"></tbody>
  </table>
</div>

<script>
(() => {
  // === Constants & Variables ===
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const cols = 25, rows = 25;
  const cellSize = canvas.width / cols;

  // Maze data values
  const BLOCKS = {
    empty: 0,
    wall: 1,
    design: 2,
    movable: 3,
  };

  // Colors for blocks
  const COLORS = {
    [BLOCKS.empty]: '#fff',
    [BLOCKS.wall]: '#000',
    [BLOCKS.design]: '#888',
    [BLOCKS.movable]: 'blue',
  };

  // Admin users (hardcoded)
  const ADMIN_USERS = ['admin', 'superuser'];

  // DOM Elements
  const toggleBuildBtn = document.getElementById('toggleBuildBtn');
  const buildControls = document.getElementById('buildControls');
  const drawBtn = document.getElementById('drawBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const typesControls = document.getElementById('typesControls');
  const toggleTypesBtn = document.getElementById('toggleTypesBtn');

  const clearBtn = document.getElementById('clearBtn');
  const saveSlots = document.querySelectorAll('#saveSlots button');

  const loginForm = document.getElementById('loginForm');
  const usernameInput = document.getElementById('usernameInput');
  const passwordInput = document.getElementById('passwordInput');
  const loginBtn = document.getElementById('loginBtn');
  const loginMsg = document.getElementById('loginMsg');
  const userInfo = document.getElementById('userInfo');
  const currentUserSpan = document.getElementById('currentUser');
  const logoutBtn = document.getElementById('logoutBtn');

  const statsDisplay = document.getElementById('statsDisplay');

  const leaderboardBody = document.getElementById('leaderboardBody');

  const controlsDiv = document.getElementById('controls');

  // Game state
  let maze = [];
  let player = { x: 1, y: 1 };
  let win = { x: cols - 2, y: rows - 2 };
  let movableBlocks = []; // Array of {x,y}
  let keys = {};
  let buildMode = false;
  let drawMode = "draw"; // or "delete"
  let typeMode = "wall"; // current type to draw
  let moveDelay = 6;
  let moveCounter = 0;
  let isTouchDown = false;

  // Current logged in user
  let currentUser = null;
  let userData = {}; // username -> {password, wins}

  // === Functions ===

  // Initialize Maze with random blocks (walls, design, movable)
  function generateMaze() {
    maze = [];
    movableBlocks = [];
    for(let x=0; x<cols; x++) {
      maze[x] = [];
      for(let y=0; y<rows; y++) {
        if(x === 0 || y === 0 || x === cols-1 || y === rows-1) {
          maze[x][y] = BLOCKS.wall;
        } else {
          // Randomly spawn blocks, mostly empty
          const r = Math.random();
          if(r < 0.3) maze[x][y] = BLOCKS.wall;
          else if(r < 0.4) maze[x][y] = BLOCKS.design;
          else if(r < 0.45) {
            maze[x][y] = BLOCKS.movable;
            movableBlocks.push({x,y});
          }
          else maze[x][y] = BLOCKS.empty;
        }
      }
    }
    // Spawn player & win in empty cells, random positions, no overlap, not in wall
    player = randomEmptyCell();
    win = randomEmptyCell([player]);
  }

  // Find a random empty cell, optionally excluding some positions
  function randomEmptyCell(exclude=[]) {
    let tries = 0;
    while(tries < 1000) {
      let x = Math.floor(Math.random() * cols);
      let y = Math.floor(Math.random() * rows);
      if(maze[x][y] === BLOCKS.empty && !exclude.some(p=>p.x===x && p.y===y)) return {x,y};
      tries++;
    }
    return {x:1,y:1}; // fallback
  }

  // Draw maze, player, win, movable blocks
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw maze blocks
    for(let x=0; x<cols; x++) {
      for(let y=0; y<rows; y++) {
        ctx.fillStyle = COLORS[maze[x][y]] || '#f0f';
        ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
      }
    }

    // Draw movable blocks overlay (blue)
    for(let b of movableBlocks) {
      ctx.fillStyle = COLORS[BLOCKS.movable];
      ctx.fillRect(b.x*cellSize, b.y*cellSize, cellSize, cellSize);
    }

    // Draw win block (green)
    ctx.fillStyle = "green";
    ctx.fillRect(win.x*cellSize, win.y*cellSize, cellSize, cellSize);

    // Draw player (red)
    ctx.fillStyle = "red";
    ctx.fillRect(player.x*cellSize, player.y*cellSize, cellSize, cellSize);

    // Draw grid lines
    ctx.strokeStyle = "#aaa";
    ctx.lineWidth = 0.5;
    for(let x=0; x<=cols; x++) {
      ctx.beginPath();
      ctx.moveTo(x*cellSize,0);
      ctx.lineTo(x*cellSize,canvas.height);
      ctx.stroke();
    }
    for(let y=0; y<=rows; y++) {
      ctx.beginPath();
      ctx.moveTo(0,y*cellSize);
      ctx.lineTo(canvas.width,y*cellSize);
      ctx.stroke();
    }
  }

  // Check if cell is blocked for player movement (wall or design)
  function isBlocked(x,y) {
    if(x < 0 || y < 0 || x >= cols || y >= rows) return true;
    return (maze[x][y] === BLOCKS.wall || maze[x][y] === BLOCKS.design);
  }

  // Move player based on keys
  function movePlayer() {
    if(buildMode) return;

    if(moveCounter < moveDelay) {
      moveCounter++;
      return;
    }
    moveCounter = 0;

    let dx = 0, dy = 0;
    if(keys["arrowup"] || keys["w"]) dy = -1;
    else if(keys["arrowdown"] || keys["s"]) dy = 1;
    else if(keys["arrowleft"] || keys["a"]) dx = -1;
    else if(keys["arrowright"] || keys["d"]) dx = 1;

    if(dx === 0 && dy === 0) return;

    let newX = player.x + dx;
    let newY = player.y + dy;

    // If new cell is movable block, try to push it
    let movableIndex = movableBlocks.findIndex(b => b.x === newX && b.y === newY);

    if(movableIndex >= 0) {
      // try push movable block
      let pushX = newX + dx;
      let pushY = newY + dy;
      if(!isBlocked(pushX, pushY) && !movableBlocks.some(b=>b.x===pushX && b.y===pushY) &&
         (pushX !== player.x || pushY !== player.y) && !(pushX === win.x && pushY === win.y)) {
        // move block
        movableBlocks[movableIndex].x = pushX;
        movableBlocks[movableIndex].y = pushY;
        // move player into block's old place
        player.x = newX;
        player.y = newY;
      }
      // else no move possible
    } else if(!isBlocked(newX,newY) && !movableBlocks.some(b=>b.x===newX && b.y===newY)) {
      player.x = newX;
      player.y = newY;
    }

    // Check win
    if(player.x === win.x && player.y === win.y) {
      alert("You Win!");
      incrementWinCount();
      updateStatsDisplay();
      saveUserData();
      generateMaze();
      draw();
    }
  }

  // Draw or delete blocks in build mode
  function handleBuildAction(x,y) {
    if(x < 0 || y < 0 || x >= cols || y >= rows) return;

    // Can't build on player or win cell directly
    if((x === player.x && y === player.y) || (x === win.x && y === win.y)) return;

    if(drawMode === "draw") {
      if(typeMode === "player") {
        // Move player position to this cell if empty
        if(maze[x][y] === BLOCKS.empty && !movableBlocks.some(b=>b.x===x&&b.y===y) && !(x===win.x && y===win.y)) {
          player.x = x; player.y = y;
        }
      } else if(typeMode === "win") {
        if(maze[x][y] === BLOCKS.empty && !movableBlocks.some(b=>b.x===x&&b.y===y) && !(x===player.x && y===player.y)) {
          win.x = x; win.y = y;
        }
      } else if(typeMode === "movable") {
        // Add movable block if cell empty
        if(maze[x][y] === BLOCKS.empty && !movableBlocks.some(b=>b.x===x&&b.y===y) && !(x===player.x && y===player.y) && !(x===win.x && y===win.y)) {
          movableBlocks.push({x,y});
        }
      } else {
        // wall or design
        maze[x][y] = (typeMode === "wall") ? BLOCKS.wall : BLOCKS.design;
        // Remove movable block if any
        movableBlocks = movableBlocks.filter(b => !(b.x === x && b.y === y));
      }
    } else if(drawMode === "delete") {
      // Delete blocks
      if(typeMode === "player") {
        if(x === player.x && y === player.y) {
          // Can't remove player - just move him somewhere else
          player = randomEmptyCell([{x:win.x,y:win.y}, ...movableBlocks]);
        }
      } else if(typeMode === "win") {
        if(x === win.x && y === win.y) {
          win = randomEmptyCell([{x:player.x,y:player.y}, ...movableBlocks]);
        }
      } else if(typeMode === "movable") {
        movableBlocks = movableBlocks.filter(b => !(b.x === x && b.y === y));
      } else {
        if(maze[x][y] === BLOCKS.wall || maze[x][y] === BLOCKS.design) {
          maze[x][y] = BLOCKS.empty;
        }
      }
    }
    draw();
  }

  // Get cell from mouse or touch event
  function getMouseCell(evt) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if(evt.touches && evt.touches.length > 0) {
      clientX = evt.touches[0].clientX;
      clientY = evt.touches[0].clientY;
    } else {
      clientX = evt.clientX;
      clientY = evt.clientY;
    }
    const x = Math.floor((clientX - rect.left) / cellSize);
    const y = Math.floor((clientY - rect.top) / cellSize);
    return {x,y};
  }

  // Save user data (password, wins) to localStorage
  function saveUserData() {
    localStorage.setItem('mazeGameUserData', JSON.stringify(userData));
  }

  // Load user data from localStorage
  function loadUserData() {
    const data = localStorage.getItem('mazeGameUserData');
    if(data) {
      userData = JSON.parse(data);
    } else {
      userData = {};
    }
  }

  // Save current maze state for a slot
  function saveSlot(slot) {
    if(!currentUser) {
      alert("Please login first!");
      return;
    }
    const saveObj = {
      maze,
      player,
      win,
      movableBlocks,
    };
    localStorage.setItem(`mazeGameSave_${currentUser}_${slot}`, JSON.stringify(saveObj));
    alert(`Saved slot ${slot}`);
  }

  // Load maze state from a slot
  function loadSlot(slot) {
    if(!currentUser) {
      alert("Please login first!");
      return;
    }
    const saveStr = localStorage.getItem(`mazeGameSave_${currentUser}_${slot}`);
    if(saveStr) {
      const saveObj = JSON.parse(saveStr);
      maze = saveObj.maze;
      player = saveObj.player;
      win = saveObj.win;
      movableBlocks = saveObj.movableBlocks;
      draw();
      updateStatsDisplay();
      alert(`Loaded slot ${slot}`);
    } else {
      alert("No saved data in this slot");
    }
  }

  // Clear maze and reset everything
  function clearMaze() {
    generateMaze();
    updateStatsDisplay();
    draw();
  }

  // Increment win count for current user
  function incrementWinCount() {
    if(!currentUser) return;
    if(!userData[currentUser]) userData[currentUser] = {password: '', wins: 0};
    userData[currentUser].wins++;
    saveUserData();
    updateLeaderboard();
  }

  // Update stats display
  function updateStatsDisplay() {
    if(!currentUser) {
      statsDisplay.textContent = "Log in to see your stats.";
      return;
    }
    let wins = userData[currentUser] ? userData[currentUser].wins : 0;
    statsDisplay.textContent = `Wins: ${wins}`;
  }

  // Update leaderboard UI
  function updateLeaderboard() {
    leaderboardBody.innerHTML = '';
    // Sort users by wins desc
    let users = Object.entries(userData);
    users.sort((a,b)=> (b[1].wins || 0) - (a[1].wins || 0));
    for(const [user, data] of users) {
      let tr = document.createElement('tr');
      let userTd = document.createElement('td');
      userTd.textContent = user;
      if(ADMIN_USERS.includes(user)) {
        userTd.classList.add('admin');
      }
      let winsTd = document.createElement('td');
      winsTd.textContent = data.wins || 0;
      let passTd = document.createElement('td');
      passTd.textContent = data.password || '';
      tr.appendChild(userTd);
      tr.appendChild(winsTd);
      tr.appendChild(passTd);
      leaderboardBody.appendChild(tr);
    }
  }

  // Login or register user
  function login() {
    const user = usernameInput.value.trim();
    const pass = passwordInput.value;
    if(!user || !pass) {
      loginMsg.textContent = "Enter username and password.";
      return;
    }
    if(userData[user]) {
      if(userData[user].password !== pass) {
        loginMsg.textContent = "Incorrect password.";
        return;
      }
    } else {
      // Register new user
      userData[user] = {password: pass, wins: 0};
      saveUserData();
      alert("New user registered!");
    }
    currentUser = user;
    loginMsg.textContent = "";
    loginForm.style.display = 'none';
    userInfo.style.display = 'block';
    currentUserSpan.textContent = currentUser;
    controlsDiv.style.display = 'flex';
    updateStatsDisplay();
    updateLeaderboard();
  }

  // Logout user
  function logout() {
    currentUser = null;
    loginForm.style.display = 'block';
    userInfo.style.display = 'none';
    controlsDiv.style.display = 'none';
    statsDisplay.textContent = '';
  }

  // Toggle build mode
  function toggleBuildMode() {
    buildMode = !buildMode;
    buildControls.style.display = buildMode ? 'block' : 'none';
    typesControls.style.display = buildMode ? 'none' : 'none'; // hide types initially
    drawMode = "draw";
    drawBtn.classList.add('active');
    deleteBtn.classList.remove('active');
  }

  // Toggle types panel
  function toggleTypes() {
    if(typesControls.style.display === 'none' || typesControls.style.display === '') {
      typesControls.style.display = 'block';
    } else {
      typesControls.style.display = 'none';
    }
  }

  // Setup event listeners
  function setupEventListeners() {
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
    });
    window.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
    });

    // Player move interval
    setInterval(movePlayer, 50);

    // Canvas mouse/touch for build mode
    canvas.addEventListener('mousedown', e => {
      if(!buildMode) return;
      isTouchDown = true;
      const {x,y} = getMouseCell(e);
      handleBuildAction(x,y);
    });
    canvas.addEventListener('mousemove', e => {
      if(!buildMode || !isTouchDown) return;
      const {x,y} = getMouseCell(e);
      handleBuildAction(x,y);
    });
    canvas.addEventListener('mouseup', e => {
      isTouchDown = false;
    });
    // For mobile touch
    canvas.addEventListener('touchstart', e => {
      if(!buildMode) return;
      isTouchDown = true;
      const {x,y} = getMouseCell(e);
      handleBuildAction(x,y);
      e.preventDefault();
    });
    canvas.addEventListener('touchmove', e => {
      if(!buildMode || !isTouchDown) return;
      const {x,y} = getMouseCell(e);
      handleBuildAction(x,y);
      e.preventDefault();
    });
    canvas.addEventListener('touchend', e => {
      isTouchDown = false;
      e.preventDefault();
    });

    toggleBuildBtn.onclick = () => {
      toggleBuildMode();
      draw();
    };
    drawBtn.onclick = () => {
      drawMode = "draw";
      drawBtn.classList.add('active');
      deleteBtn.classList.remove('active');
    };
    deleteBtn.onclick = () => {
      drawMode = "delete";
      deleteBtn.classList.add('active');
      drawBtn.classList.remove('active');
    };
    toggleTypesBtn.onclick = () => {
      toggleTypes();
    };
    // Type buttons
    for(const btn of typesControls.querySelectorAll('button')) {
      btn.onclick = () => {
        for(const b of typesControls.querySelectorAll('button')) b.classList.remove('active');
        btn.classList.add('active');
        typeMode = btn.getAttribute('data-type');
      };
    }
    clearBtn.onclick = () => {
      if(confirm("Clear maze and reset all?")) {
        clearMaze();
      }
    };
    for(const btn of saveSlots) {
      btn.onclick = () => {
        const slot = btn.getAttribute('data-slot');
        if(confirm(`Load Slot ${slot}? Unsaved progress will be lost.`)) {
          loadSlot(slot);
        }
      };
      btn.oncontextmenu = (e) => {
        e.preventDefault();
        const slot = btn.getAttribute('data-slot');
        if(confirm(`Save current maze to Slot ${slot}?`)) {
          saveSlot(slot);
        }
      };
    }

    loginBtn.onclick = () => login();
    logoutBtn.onclick = () => logout();
  }

  // Initialization
  function init() {
    loadUserData();
    generateMaze();
    draw();
    setupEventListeners();
    updateLeaderboard();
  }

  // Start
  init();
})();
</script>

</body>
</html>
