<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LtpMer's Maze Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // If you want to use Analytics, uncomment the line below and ensure 'getAnalytics' is imported above.
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // --- IMPORTANT: FOR EXTERNAL HOSTING, REPLACE THIS WITH YOUR ACTUAL FIREBASE CONFIG ---
        // You MUST ensure this 'myFirebaseConfig' object contains your OWN Firebase project's configuration.
        // This configuration can be found in your Firebase project settings (web app section).
        // The 'projectId' field is crucial for connecting to your Firestore database.
        
        const myFirebaseConfig = {
          apiKey: "AIzaSyAB3UcTTArjYHrhcDFo780HsK2gIYVGXjQ",
          authDomain: "mazegame-27b3f.firebaseapp.com",
          projectId: "mazegame-27b3f",
          storageBucket: "mazegame-27b3f.firebase-storage.app",
          messagingSenderId: "632041065509",
          appId: "1:632041065509:web:659ed37bf4475df8da83cc",
          measurementId: "G-EFMZ0KCNM5" // Optional: Include if you want Firebase Analytics
        };
        // This line is crucial: it makes your Firebase config globally accessible to the game logic.
        // For Canvas environment, __firebase_config is often provided as a string.
        // We'll prioritize the Canvas-provided __firebase_config if available.
        // If __firebase_config from Canvas is undefined, it falls back to myFirebaseConfig.
        window.__firebase_config = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : myFirebaseConfig;
        
        // --------------------------------------------------------------------------------------

        // Global variables for Firebase (will be populated by the environment or manually)
        // If running outside Canvas, __app_id and __initial_auth_token will be undefined.
        // The game will use the manually provided window.__firebase_config.
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : (window.__firebase_config ? window.__firebase_config.appId : 'default-app-id');
        window.__initial_auth_token = typeof __initial_auth_token !== 'undefined' ? window.__initial_auth_token : null;

        console.log("Firebase config being used for initialization:", window.__firebase_config); // Added for debugging
        console.log("App ID being used:", window.__app_id); // Added for debugging

        // Initialize Firebase
        if (window.__firebase_config && window.__firebase_config.projectId) { // Added check for projectId
            try {
                window.firebaseApp = initializeApp(window.__firebase_config);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                // If you enabled Analytics, uncomment the line below:
                // window.analytics = getAnalytics(window.firebaseApp);

                // Sign in anonymously or with custom token
                if (window.__initial_auth_token) {
                    signInWithCustomToken(window.auth, window.__initial_auth_token)
                        .then(() => {
                            console.log("Firebase signed in with custom token.");
                            window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                            document.dispatchEvent(new Event('firebaseAuthReady'));
                        })
                        .catch((error) => {
                            console.error("Error signing in with custom token:", error);
                            signInAnonymously(window.auth)
                                .then(() => {
                                    console.log("Firebase signed in anonymously.");
                                    window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                                    document.dispatchEvent(new Event('firebaseAuthReady'));
                                })
                                .catch((anonError) => {
                                    console.error("Error signing in anonymously:", anonError);
                                    window.userId = crypto.randomUUID(); // Fallback to random ID
                                    document.dispatchEvent(new Event('firebaseAuthReady'));
                                });
                        });
                } else {
                    signInAnonymously(window.auth)
                        .then(() => {
                            console.log("Firebase signed in anonymously.");
                            window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                            document.dispatchEvent(new Event('firebaseAuthReady'));
                        })
                        .catch((error) => {
                            console.error("Error signing in anonymously:", error);
                            window.userId = crypto.randomUUID(); // Fallback to random ID
                            document.dispatchEvent(new Event('firebaseAuthReady'));
                        });
                }

                onAuthStateChanged(window.auth, (user) => {
                    if (user) {
                        window.userId = user.uid;
                        console.log("Auth state changed, user ID:", window.userId);
                    } else {
                        console.log("Auth state changed, no user.");
                        // If user logs out, userId might need to be re-evaluated or handled
                    }
                });
            } catch (initError) {
                console.error("Error initializing Firebase App:", initError);
                console.warn("Running without Firebase features due to initialization error.");
                window.userId = crypto.randomUUID(); // Generate a random ID if Firebase initialization fails
                document.dispatchEvent(new Event('firebaseAuthReady'));
            }
        } else {
            console.warn("Firebase config not found or projectId missing. Running without Firebase features.");
            window.userId = crypto.randomUUID(); // Generate a random ID if Firebase is not configured
            document.dispatchEvent(new Event('firebaseAuthReady'));
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #e2e8f0; /* Light text */
            position: relative; /* Needed for absolute positioning of info button */
            /* Removed overflow: hidden; to allow scrolling */
        }

        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90%;
            width: 700px; /* Max width for larger screens */
            gap: 20px;
            position: relative; /* For z-index */
        }

        h1 {
            color: #63b3ed; /* Blue title */
            margin-bottom: 15px;
            font-size: 2.5rem;
            text-align: center;
        }

        canvas {
            background-color: #f0f0f0; /* Light grey maze background for paths */
            border: 5px solid #4a5568; /* Darker border for canvas */
            border-radius: 10px;
            display: block;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center;
            gap: 15px;
            width: 100%;
        }

        button {
            background-color: #48bb78; /* Green button */
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 200px; /* Adjust max-width for better distribution */
        }

        button:hover {
            background-color: #38a169; /* Darker green on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Specific button styles */
        .start-screen-button { /* For Play, Customization, Menu on start screen */
            background-color: #63b3ed; /* Blue for main buttons */
            font-weight: bold;
            font-size: 1.8rem; /* Larger font for main buttons */
            padding: 20px 40px;
            border-radius: 15px;
            max-width: 300px;
            min-width: 150px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        .start-screen-button:hover {
            background-color: #4299e1;
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        .start-screen-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #customizationButtonStart, #menuButtonStart, #leaderboardButton { /* Added leaderboard button */
            background-color: #f6ad55; /* Orange for Customization */
            font-size: 1.2rem; /* Smaller than Play, larger than game controls */
            padding: 15px 30px;
            max-width: 250px;
        }
        #customizationButtonStart:hover, #menuButtonStart:hover, #leaderboardButton:hover {
            background-color: #ed8936;
        }

        #menuButtonStart {
            background-color: #a0aec0; /* Grey for Menu */
        }
        #menuButtonStart:hover {
            background-color: #718096;
        }

        /* Daily Level Display */
        .daily-level-container {
            background-color: #4a5568; /* Darker grey for daily level box */
            border-radius: 10px;
            padding: 15px 20px;
            margin-top: 20px;
            width: 80%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .daily-level-container h3 {
            color: #63b3ed;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        .daily-level-container p {
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        .daily-level-container button {
            background-color: #4CAF50;
            font-size: 1.1rem;
            padding: 10px 20px;
            max-width: 250px;
        }
        .daily-level-container button:hover {
            background-color: #388E3C;
        }


        /* Touch controls for mobile */
        .touch-controls {
            display: none; /* Hidden by default, shown on smaller screens */
            position: absolute; /* Position absolutely within game-play-area */
            /* Default position, will be overridden by localStorage */
            left: 20px; 
            bottom: 20px; 

            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 10px;
            width: 200px;
            height: 200px;
            justify-items: center;
            align-items: center;
            z-index: 5; /* Ensure it's above canvas but below modals */
            cursor: grab; /* Indicate draggable */
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }

        .touch-button {
            background-color: #63b3ed; /* Blue for touch buttons */
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: pointer; /* Cursor for individual buttons */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .touch-button:active {
            background-color: #4299e1;
            transform: scale(0.95);
        }

        .touch-button.up { grid-area: up; }
        .touch-button.down { grid-area: down; }
        .touch-button.left { grid-area: left; }
        .touch-button.right { grid-area: right; }

        /* Info and Login Buttons in corner */
        .corner-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .corner-buttons button {
            background-color: #f6ad55; /* Orange color */
            color: #2d3748;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: none;
            min-width: unset;
            text-align: center;
            flex-grow: 0; /* Prevent them from growing */
            max-width: unset; /* Remove max-width constraint */
        }

        .corner-buttons button:hover {
            background-color: #ed8936;
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        .corner-buttons button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #loginButton.logged-in {
            background-color: #e53e3e; /* Red for logout */
        }
        #loginButton.logged-in:hover {
            background-color: #c53030;
        }


        /* General Modal Styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100; /* Ensure it's on top of everything */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            text-align: center;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            color: #e2e8f0;
            /* Added for scrollability */
            max-height: 90vh; /* Limit height to 90% of viewport height */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h2 {
            color: #63b3ed;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .modal-content p {
            line-height: 1.6;
            margin-bottom: 25px;
            font-size: 1.1rem;
        }

        .modal-content .close-button {
            background-color: #e53e3e; /* Red close button */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            border: none;
        }

        .modal-content .close-button:hover {
            background-color: #c53030;
            transform: translateY(-1px);
        }

        /* Game State Specific Displays */
        .start-screen, .game-play-area, .build-mode-area {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            justify-content: center;
            gap: 20px;
        }

        .start-screen.active, .game-play-area.active, .build-mode-area.active {
            display: flex; /* Shown when active */
        }

        /* Styles for buttons inside menu modal */
        .menu-modal-buttons button {
            background-color: #4CAF50; /* Green for menu options */
            margin-bottom: 10px;
            max-width: 300px;
        }
        .menu-modal-buttons button:hover {
            background-color: #388E3C;
        }
        #clearBuildGridButton {
            background-color: #e53e3e; /* Red for clear button */
        }
        #clearBuildGridButton:hover {
            background-color: #c53030;
        }

        /* Build Mode Tool Buttons */
        .build-tools {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 15px;
            width: 100%;
        }
        .build-tools button {
            background-color: #63b3ed; /* Blue for tools */
            flex-grow: 0;
            max-width: 120px;
            padding: 8px 15px;
            font-size: 0.9rem;
        }
        .build-tools button.active-tool {
            background-color: #4299e1;
            box-shadow: 0 0 0 3px #4299e1, 0 0 0 6px #63b3ed; /* Highlight active tool */
        }
        #saveLevelButton, #publishLevelButton { /* Added publish button */
            background-color: #4CAF50; /* Green for save */
            font-weight: bold;
            font-size: 1.1rem;
            padding: 10px 20px;
        }
        #saveLevelButton:hover, #publishLevelButton:hover {
            background-color: #388E3C;
        }

        /* Customization Modal Styles */
        .customization-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        .customization-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .customization-option label {
            flex-basis: 40%;
            text-align: left;
            font-size: 1.1rem;
        }
        .customization-option input[type="color"] {
            flex-basis: 55%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .customization-option input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .customization-option input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 8px;
        }
        .customization-option input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 8一層;
        }

        /* Level Lists (My Levels & Community Levels) */
        .level-list-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            width: 100%;
            text-align: left;
        }
        .level-list-container > div { /* Target direct children div of level-list-container */
            display: flex;
            flex-direction: column; /* Stack name/metadata and buttons vertically */
            padding: 8px 0;
            border-bottom: 1px dashed #4a5568;
            position: relative; /* For "By User" positioning */
            padding-bottom: 25px; /* Add space for "By User" */
        }
        .level-list-container > div:last-child {
            border-bottom: none;
        }
        .level-list-container button {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 0.9rem;
            max-width: 80px;
            flex-shrink: 0;
        }
        .level-list-container .level-name-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
        }
        .level-list-container .level-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: bold;
            font-size: 1.1rem;
            margin-right: 10px; /* Space between name and metadata */
        }
        .level-list-container .play-level-button {
            background-color: #68d391;
        }
        .level-list-container .play-level-button:hover {
            background-color: #48bb78;
        }
        .level-list-container .delete-level-button {
            background-color: #e53e3e;
        }
        .level-list-container .delete-level-button:hover {
            background-color: #c53030;
        }
        .level-list-container .edit-level-button { /* New edit button style */
            background-color: #f6ad55; /* Orange for edit */
        }
        .level-list-container .edit-level-button:hover {
            background-color: #ed8936;
        }
        .level-list-container .set-daily-button { /* New style for admin button */
            background-color: #FFD700; /* Gold */
            color: #2d3748;
        }
        .level-list-container .set-daily-button:hover {
            background-color: #DAA520; /* Darker Gold */
        }
        /* New style for "Set as Official" button */
        .level-list-container .set-official-button {
            background-color: #805AD5; /* Purple */
            color: white;
        }
        .level-list-container .set-official-button:hover {
            background-color: #6B46C1;
        }
        /* New style for difficulty display */
        .level-difficulty {
            font-size: 0.8em;
            color: #a0aec0;
            margin-left: 5px;
            text-transform: capitalize; /* Make it look nice */
        }
        .level-bricks {
            font-size: 0.8em;
            color: #f6ad55;
            margin-left: 5px;
        }
        .level-metadata {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0; /* Prevent metadata from shrinking */
        }
        .level-buttons-row {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            width: 100%;
            margin-top: 10px;
        }
        .level-creator { /* New style for "By User" */
            position: absolute;
            bottom: 5px;
            left: 10px;
            font-size: 0.75em;
            color: #a0aec0;
        }


        /* Leaderboard Specific Styles */
        .leaderboard-list-container {
            max-height: 300px; /* Make it scrollable */
            overflow-y: auto;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            width: 100%;
            text-align: left;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #4a5568;
        }
        .leaderboard-entry:last-child {
            border-bottom: none;
        }
        .leaderboard-entry .rank {
            font-weight: bold;
            color: #63b3ed;
            width: 30px;
            flex-shrink: 0;
        }
        .leaderboard-entry .player-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px;
        }
        .leaderboard-entry .level-name-lb { /* This will be removed, but keeping style for now */
            font-size: 0.9em;
            color: #a0aec0;
            margin-right: 10px;
        }
        .leaderboard-entry .time { /* This will be removed, but keeping style for now */
            font-weight: bold;
            color: #4CAF50;
            flex-shrink: 0;
        }
        .leaderboard-entry .bricks { /* New style for bricks display */
            font-weight: bold;
            color: #f6ad55; /* Orange for bricks */
            margin-left: 10px;
            flex-shrink: 0;
            font-size: 1.1em; /* Make bricks stand out */
        }
        .leaderboard-entry .difficulty-lb { /* This will be removed, but keeping style for now */
            font-size: 0.8em;
            color: #a0aec0;
            margin-left: 5px;
            text-transform: capitalize;
        }


        /* Login Modal specific styles */
        .login-form-group {
            margin-bottom: 15px;
            text-align: left;
        }
        .login-form-group label {
            display: block;
            margin-bottom: 5px;
            color: #e2e8f0;
        }
        .login-form-group input {
            width: calc(100% - 20px);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1rem;
        }
        .login-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        .login-buttons button {
            flex-grow: 1;
            max-width: 150px;
        }
        .login-buttons #loginSubmitButton {
            background-color: #63b3ed;
        }
        .login-buttons #loginSubmitButton:hover {
            background-color: #4299e1;
        }
        .login-buttons #loginCancelButton {
            background-color: #a0aec0;
        }
        #loginCancelButton:hover {
            background-color: #718096;
        }

        /* Specific style for the Eraser button */
        #toolEraser {
            background-color: #e53e3e; /* Red color for eraser */
        }
        #toolEraser:hover {
            background-color: #c53030; /* Darker red on hover */
        }

        /* NEW: Difficulty & Bricks controls in Community Levels */
        .community-level-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
            align-items: center;
            width: 100%; /* Ensure it takes full width within its parent */
            justify-content: flex-end; /* Align to right */
        }
        .community-level-actions select {
            background-color: #4a5568;
            color: #e2e8f0;
            border: 1px solid #63b3ed;
            border-radius: 5px;
            padding: 5px 8px;
            font-size: 0.85rem;
            flex-grow: 1;
            min-width: 80px;
            max-width: 120px;
        }
        .community-level-actions input[type="number"] {
            background-color: #4a5568;
            color: #e2e8f0;
            border: 1px solid #63b3ed;
            border-radius: 5px;
            padding: 5px 8px;
            font-size: 0.85rem;
            width: 50px;
            text-align: center;
        }
        .community-level-actions button {
            padding: 5px 10px;
            font-size: 0.85rem;
            flex-grow: 0;
            max-width: unset; /* Remove max-width constraint */
        }
        .community-level-actions .update-level-props-button {
            background-color: #68d391; /* Green for update */
        }
        .community-level-actions .update-level-props-button:hover {
            background-color: #48bb78;
        }
        /* New style for "Set as Daily" button */
        .community-level-actions .set-daily-button-community {
            background-color: #FFD700; /* Gold */
            color: #2d3748;
        }
        .community-level-actions .set-daily-button-community:hover {
            background-color: #DAA520; /* Darker Gold */
        }


        /* Community search bar styling */
        .community-search-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            width: 100%;
            justify-content: center;
        }

        .community-search-bar input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #63b3ed;
            background-color: #4a5568;
            color: #e2e8f0;
            font-size: 1rem;
        }

        .community-search-bar button {
            flex-shrink: 0;
            background-color: #63b3ed;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease;
            border: none;
            max-width: unset; /* Remove max-width constraint */
        }

        .community-search-bar button:hover {
            background-color: #4299e1;
        }

        /* Health Display */
        #playerHealthDisplay {
            font-size: 1.2rem;
            font-weight: bold;
            color: #e53e3e; /* Red for health */
            margin-top: 10px;
            text-align: center;
        }

        /* Custom Block Editor Modal */
        #customBlockEditorModalOverlay .modal-content {
            max-width: 600px;
        }
        .custom-block-editor-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
            text-align: left;
        }
        .custom-block-editor-form label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        .custom-block-editor-form input[type="text"],
        .custom-block-editor-form textarea {
            width: calc(100% - 22px); /* Adjust for padding and border */
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1rem;
        }
        .custom-block-editor-form textarea {
            min-height: 150px;
            font-family: 'monospace';
        }
        .custom-block-editor-form .color-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .custom-block-editor-form input[type="color"] {
            width: 50px;
            height: 35px;
            padding: 0;
            border-radius: 5px;
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .custom-block-editor-form input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .custom-block-editor-form input[type="color"]::-webkit-color-swatch { border: none; border-radius: 5px; }
        .custom-block-editor-form input[type="color"]::-moz-color-swatch { border: none; border-radius: 5px; }

        .custom-block-editor-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .custom-block-editor-buttons button {
            flex-grow: 1;
            max-width: 150px;
        }
        #saveCustomBlockDefinitionButton { background-color: #4CAF50; }
        #saveCustomBlockDefinitionButton:hover { background-color: #388E3C; }
        #deleteCustomBlockDefinitionButton { background-color: #e53e3e; }
        #deleteCustomBlockDefinitionButton:hover { background-color: #c53030; }
        #closeCustomBlockEditorButton { background-color: #a0aec0; }
        #closeCustomBlockEditorButton:hover { background-color: #718096; }

        .custom-block-definitions-list-container {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            width: 100%;
            text-align: left;
        }
        .custom-block-definitions-list-container > div {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px dashed #4a5568;
        }
        .custom-block-definitions-list-container > div:last-child {
            border-bottom: none;
        }
        .custom-block-definitions-list-container button {
            margin-left: 5px;
            padding: 3px 8px;
            font-size: 0.8rem;
            max-width: 70px;
        }
        .custom-block-definitions-list-container .select-custom-block-button { background-color: #63b3ed; }
        .custom-block-definitions-list-container .select-custom-block-button:hover { background-color: #4299e1; }
        .custom-block-definitions-list-container .edit-custom-block-button { background-color: #f6ad55; }
        .custom-block-definitions-list-container .edit-custom-block-button:hover { background-color: #ed8936; }
        .custom-block-definitions-list-container .delete-custom-block-button { background-color: #e53e3e; }
        .custom-block-definitions-list-container .delete-custom-block-button:hover { background-color: #c53030; }


        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .game-container {
                padding: 20px;
                width: 100%;
            }
            .message-box {
                font-size: 1rem;
                padding: 10px 15px;
            }
            button {
                padding: 10px 20px;
                font-size: 1rem;
            }
            .touch-controls {
                display: grid; /* Show touch controls on small screens */
                position: absolute; /* Keep absolute positioning */
                /* Initial position will be set by JS from localStorage */
                width: 150px; /* Smaller touch controls */
                height: 150px;
            }
            .touch-button {
                width: 45px; /* Smaller buttons */
                height: 45px;
                font-size: 1.2rem;
            }
            .corner-buttons {
                top: 10px;
                right: 10px;
                gap: 5px;
            }
            .corner-buttons button {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            .modal-content {
                padding: 20px;
            }
            .modal-content h2 {
                font-size: 1.7rem;
            }
            .modal-content p {
                font-size: 1rem;
            }
            .button-row {
                flex-direction: column; /* Stack buttons vertically on small screens */
            }
            button {
                max-width: 100%; /* Full width for stacked buttons */
            }
            .start-screen-button {
                font-size: 1.5rem;
                padding: 15px 30px;
            }
            #customizationButtonStart, #menuButtonStart, #leaderboardButton {
                font-size: 1.1rem;
                padding: 12px 25px;
            }
            .level-list-container > div {
                padding-bottom: 35px; /* More space for "By User" on small screens */
            }
            .community-level-actions {
                flex-direction: column; /* Stack admin controls vertically */
                align-items: flex-start;
            }
            .community-level-actions select,
            .community-level-actions input[type="number"],
            .community-level-actions button {
                width: 100%;
                max-width: 100%;
                margin-left: 0 !important;
            }
            .community-search-bar {
                flex-direction: column;
            }
            .community-search-bar input,
            .community-search-bar button {
                width: 100%;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Start Screen -->
        <div id="startScreen" class="start-screen">
            <h1>LtpMer's Maze Game</h1>
            <button id="playButton" class="start-screen-button">Play</button>
            <button id="customizationButtonStart" class="start-screen-button">Customization</button>
            <button id="menuButtonStart" class="start-screen-button">Menu</button>
            <button id="leaderboardButton" class="start-screen-button">Leaderboard</button> <!-- New Leaderboard Button -->

            <div id="dailyLevelContainer" class="daily-level-container" style="display: none;">
                <h3>Daily Level</h3>
                <p id="dailyLevelName">Loading daily level...</p>
                <button id="playDailyLevelButton">Play Daily Level</button>
            </div>
        </div>

        <!-- Game Play Area (for levels, random maze, random blocks) -->
        <div id="gamePlayArea" class="game-play-area">
            <canvas id="mazeCanvas"></canvas>
            <div class="message-box" id="messageBox">Use arrow keys or WASD to move!</div>
            <div id="playerHealthDisplay">Health: ❤️ 10</div> <!-- Health Display -->
            <div class="controls">
                <div class="button-row">
                    <button id="nextLevelButton" style="display: none;">Next Level</button> <!-- Only for Level Mode -->
                    <button id="editCurrentLevelButton">Edit Current Level</button> <!-- Renamed from saveCurrentLevelButton -->
                    <button id="backToMainMenuButtonGame">Back to Main Menu</button>
                </div>
                <div class="touch-controls">
                    <button class="touch-button up" data-direction="up">&#9650;</button>
                    <button class="touch-button left" data-direction="left">&#9664;</button>
                    <button class="touch-button right" data-direction="right">&#9654;</button>
                    <button class="touch-button down" data-direction="down">&#9660;</button>
                </div>
            </div>
        </div>

        <!-- Build Mode Area -->
        <div id="buildModeArea" class="build-mode-area">
            <h1>Build Mode</h1>
            <canvas id="buildCanvas"></canvas>
            <div class="message-box" id="buildMessageBox">Click to place/remove blocks!</div>
            <div class="controls">
                <div class="build-tools" id="drawingTools">
                    <button id="toolEraser">Eraser</button> <!-- New Eraser Tool -->
                    <button id="toolWall" class="active-tool">Wall</button>
                    <button id="toolPath">Path</button>
                    <button id="toolPlayer">Player</button>
                    <button id="toolWinpad">Win Pad</button>
                    <button id="toolDamagingBlock">Damaging</button> <!-- New Damaging Block Tool -->
                    <button id="toolPushBlock">Push</button>
                    <button id="toolCustomBlock">Custom</button> <!-- New Custom Block Tool -->
                    <button id="toolSelection">Selection</button> <!-- New Selection Tool -->
                </div>
                <div class="button-row" id="selectionActions" style="display: none;">
                    <button id="fillSelectionButton">Fill Selected (Current Tool)</button>
                    <button id="clearSelectionButton">Clear Selected (Path)</button>
                    <button id="exitSelectionButton">Exit Selection</button> <!-- New Exit Selection Button -->
                </div>
                <div class="button-row">
                    <button id="clearBuildGridButton">Clear Grid</button>
                    <button id="saveLevelButton">Save Level</button>
                    <button id="publishLevelButton">Publish Level</button> <!-- New Publish Button -->
                    <button id="backToMainMenuButtonBuild">Back to Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Info and Login Buttons in corner -->
    <div class="corner-buttons">
        <button id="guidesButton">Guides</button>
        <button id="loginButton">Login</button>
        <button id="infoButton">Info</button>
    </div>

    <!-- Info Modal -->
    <div id="infoModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Welcome to Maze Explorer!</h2>
            <p>
                Navigate the red player block to the green winpad.
                Use **Arrow Keys** or **WASD** to move.
                <br><br>
                **Play:** Jump straight into predefined levels.
                <br>
                **Customization:** Change game visuals.
                <br>
                **Menu:** Access other game modes like random generation, build mode, or saved levels.
            </p>
            <button class="close-button" id="closeInfoModalButton">Close</button>
        </div>
    </div>

    <!-- Customization Modal -->
    <div id="customizationModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Customization</h2>
            <div class="customization-options">
                <div class="customization-option">
                    <label for="playerColorPicker">Player Color:</label>
                    <input type="color" id="playerColorPicker">
                </div>
                <div class="customization-option">
                    <label for="wallColorPicker">Wall Color:</label>
                    <input type="color" id="wallColorPicker">
                </div>
                <div class="customization-option">
                    <label for="pathColorPicker">Path Color:</label>
                    <input type="color" id="pathColorPicker">
                </div>
            </div>
            <button class="close-button" id="closeCustomizationModalButton">Close</button>
        </div>
    </div>

    <!-- Menu Modal -->
    <div id="menuModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Menu</h2>
            <p id="userIdDisplay">User ID: Loading...</p>
            <p id="playerBricksDisplay">Bricks: � 0</p> <!-- New Bricks Display -->
            <p>Choose your game mode:</p>
            <div class="button-row menu-modal-buttons">
                <button id="startRandomMazeButton">Start Random Maze</button>
                <button id="startRandomBlocksButton">Start Random Blocks</button>
                <button id="buildModeButton">Build Mode</button>
                <button id="communityLevelsButtonMenu">Community Levels</button> <!-- NEW: Button to open Community Levels modal -->
            </div>
            <h3>My Levels</h3>
            <div id="myLevelsList" class="level-list-container">
                <!-- Levels will be loaded here -->
                Loading levels...
            </div>
            <button id="refreshMyLevelsButton">Refresh My Levels</button>
            <button class="close-button" id="closeMenuModalButton">Close</button>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="loginModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Simulated Login</h2>
            <p>
                This is a **simulated login** for demonstration purposes.
                It does not connect to a real authentication server or store your password securely.
                Your entered Player Name will be displayed in the Menu.
            </p>
            <div class="login-form-group">
                <label for="playerNameInput">Player Name:</label>
                <input type="text" id="playerNameInput" placeholder="Enter your player name" autocomplete="username">
            </div>
            <div class="login-form-group">
                <label for="passwordInput">Password:</label>
                <input type="password" id="passwordInput" placeholder="Enter a password (not saved)" autocomplete="current-password">
            </div>
            <div class="login-buttons">
                <button id="loginSubmitButton">Login</button>
                <button id="loginCancelButton">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Community Levels Modal (Now a separate modal) -->
    <div id="communityLevelsModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Community Levels</h2>
            <p>Search and play levels created by others!</p> <!-- Moved from menu modal -->
            <div class="community-search-bar"> <!-- Moved from menu modal -->
                <input type="text" id="communityLevelSearchInputModal" placeholder="Search by name or ID">
                <button id="searchCommunityLevelsButtonModal">Search</button>
            </div>
            <div id="communityLevelsListModal" class="level-list-container"> <!-- Moved from menu modal -->
                Loading community levels...
            </div>
            <button id="refreshCommunityLevelsButtonModal">Refresh Community Levels</button>
            <button class="close-button" id="closeCommunityLevelsModalButton">Close</button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Leaderboard</h2>
            <div id="leaderboardList" class="leaderboard-list-container">
                <!-- Leaderboard entries will be loaded here -->
                Loading leaderboard...
            </div>
            <button id="refreshLeaderboardButton">Refresh Leaderboard</button>
            <button class="close-button" id="closeLeaderboardModalButton">Close</button>
        </div>
    </div>

    <!-- Custom Block Editor Modal -->
    <div id="customBlockEditorModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Custom Block Editor</h2>
            <form class="custom-block-editor-form">
                <label for="customBlockNameInput">Block ID (Unique Name):</label>
                <input type="text" id="customBlockNameInput" placeholder="e.g., 'teleport_trap', 'healing_pad'">
                
                <div class="color-input-group">
                    <label for="customBlockColorPicker">Block Color:</label>
                    <input type="color" id="customBlockColorPicker" value="#800080">
                </div>

                <label for="customBlockScriptInput">Behavior Script (JSON Array):</label>
                <textarea id="customBlockScriptInput" placeholder='[{"type": "message", "params": {"text": "Hello!"}}, {"type": "wait", "params": {"duration": 1000}}]'></textarea>
                <p style="font-size: 0.9em; color: #a0aec0; text-align: left;">
                    Supported actions: "wait", "damagePlayer", "message", "teleportPlayer", "changeBlockType", "loop".<br>
                    For "teleportPlayer" and "changeBlockType", use "self" for targetX/Y to refer to the block's own position.
                </p>
                <div class="custom-block-editor-buttons">
                    <button type="button" id="saveCustomBlockDefinitionButton">Save Definition</button>
                    <button type="button" id="deleteCustomBlockDefinitionButton" style="display: none;">Delete Current</button>
                </div>
            </form>

            <h3>My Custom Block Definitions</h3>
            <div id="customBlockDefinitionsList" class="custom-block-definitions-list-container">
                <!-- Custom block definitions will be loaded here -->
                Loading definitions...
            </div>
            <button class="close-button" id="closeCustomBlockEditorButton" style="margin-top: 20px;">Close Editor</button>
        </div>
    </div>

    <script type="module">
        // Import Firestore functions
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Declare variables globally, but initialize them inside window.onload
        let startScreen, gamePlayArea, buildModeArea, infoButton, loginButton, guidesButton;
        let playButton, customizationButtonStart, menuButtonStart, leaderboardButton, dailyLevelContainer, dailyLevelName, playDailyLevelButton;
        let mazeCanvas, mazeCtx, messageBox, nextLevelButton, editCurrentLevelButton, backToMainMenuButtonGame, touchControls;
        let buildCanvas, buildCtx, buildMessageBox, clearBuildGridButton, saveLevelButton, publishLevelButton, backToMainMenuButtonBuild;
        let infoModalOverlay, closeInfoModalButton, customizationModalOverlay, closeCustomizationModalButton, menuModalOverlay, closeMenuModalButton, loginModalOverlay, playerNameInput, passwordInput, loginSubmitButton, loginCancelButton;
        // Removed guidesModalOverlay and closeGuidesModalButton as they are no longer needed
        let communityLevelsModalOverlay, communityLevelsListInMenu, levelSearchInput, searchCommunityLevelsButton, refreshCommunityLevelsButton; // Removed levelSearchInput, searchCommunityLevelsButton, refreshCommunityLevelsButton from menu modal context
        let communityLevelSearchInputModal, searchCommunityLevelsButtonModal, communityLevelsListModal, refreshCommunityLevelsButtonModal, closeCommunityLevelsModalButton;
        let startRandomMazeButton, startRandomBlocksButton, buildModeButton, userIdDisplay, playerBricksDisplay, myLevelsList, refreshMyLevelsButton;
        let playerColorPicker, wallColorPicker, pathColorPicker;
        let drawingToolsContainer, selectionActionsContainer;
        let toolWall, toolEraser, toolPath, toolPlayer, toolWinpad, toolPushBlock, toolSelection; // Removed toolTrigger, toolMovingBlock
        let toolDamagingBlock, toolCustomBlock; // Added new tools
        let fillSelectionButton, clearSelectionButton, exitSelectionButton;
        let leaderboardList, refreshLeaderboardButton, closeLeaderboardModalButton;
        let communityLevelsButtonMenu; // NEW: Button for Community Levels in Menu

        // Custom Block Editor elements
        let customBlockEditorModalOverlay, customBlockNameInput, customBlockColorPicker, customBlockScriptInput, saveCustomBlockDefinitionButton, deleteCustomBlockDefinitionButton, customBlockDefinitionsList, closeCustomBlockEditorButton;

        // Maze dimensions
        const MAZE_WIDTH = 31;
        const MAZE_HEIGHT = 31;
        let BLOCK_SIZE = 15;

        // Colors
        let PLAYER_COLOR = '#0000FF'; // Blue
        let WALL_COLOR = '#000000';
        let PATH_COLOR = '#f0f0f0';
        const END_COLOR = '#4CAF50';
        const PUSH_BLOCK_COLOR = '#FFD700';
        const DAMAGING_BLOCK_COLOR = '#FF4500'; // Orange-Red
        const CUSTOM_BLOCK_DEFAULT_COLOR = '#800080'; // Purple

        // Block Types
        const BLOCK_TYPES = {
            PATH: 0,
            WALL: 1,
            PLAYER_START: 2,
            WINPAD: 3,
            PUSH_BLOCK: 6,
            DAMAGING_BLOCK: 7, // New damaging block
            CUSTOM_BLOCK: 8 // New custom block
        };

        let currentBuildTool = BLOCK_TYPES.WALL; // The currently active tool for drawing/selection
        let lastSelectedDrawingTool = BLOCK_TYPES.WALL; // Stores the last non-selection tool chosen

        let isDrawing = false; // Flag for hold-click drawing
        let selectionStartPoint = null; // {x, y} for the first click in selection mode
        let selectionEndPoint = null;   // {x, y} for the current/last mouse position in selection mode
        let currentSelectionRect = null; // {x1, y1, x2, y2} normalized selection rectangle


        // Game state variables
        let mazeGrid = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(BLOCK_TYPES.WALL));
        let buildGrid = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(BLOCK_TYPES.PATH));
        
        let player = { x: 0, y: 0 };
        let end = { x: MAZE_WIDTH - 1, y: MAZE_HEIGHT - 1 };
        let gameWon = false;
        let gameStartTime = 0;
        let currentLevelId = null; // ID of the level currently being played (for leaderboard)
        let currentLevelName = ''; // Name of the level currently being played (for leaderboard)

        const PLAYER_MAX_HEALTH = 10;
        let currentHealth = PLAYER_MAX_HEALTH;
        let playerHealthDisplay; // Reference to the HTML element

        let currentPlayerName = "Anonymous";
        let playerBricks = 0;
        let editingLevelId = null; // New: Stores the ID of the level being edited, if any

        // Custom Block Definitions
        let customBlockDefinitions = {}; // Stores {customId: {color, script}}
        let currentSelectedCustomBlockId = null; // The ID of the custom block definition chosen for placement.
        let editingCustomBlockId = null; // The ID of the custom block definition currently being edited in the modal.

        // Game Modes
        const GAME_MODES = {
            LEVEL: 'level', // Now refers to official levels loaded from Firestore
            MAZE: 'maze',
            BLOCKS: 'blocks',
            BUILD: 'build',
            SAVED_LEVEL: 'saved_level',
            COMMUNITY_LEVEL: 'community_level'
        };
        let currentGameType = GAME_MODES.LEVEL;
        let currentLevelIndex = 0; // Index within the `officialPlayableLevels` array
        let currentLevelDifficulty = ''; // New: Difficulty of the level currently being played
        let currentLevelBrickReward = 0; // New: Brick reward for the level currently being played

        let officialPlayableLevels = []; // Array to hold levels fetched from Firestore for the "Play" button
        let currentDailyLevel = null;
        
        // Initializes the `mazeGrid` with all blocks set to `WALL`
        function initMazeGrid() {
            mazeGrid = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                const row = [];
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    row.push(BLOCK_TYPES.WALL); // Initialize all as walls
                }
                mazeGrid.push(row);
            }
        }

        // Initializes the `buildGrid` with all blocks set to `PATH` for a clear canvas
        function initBuildGrid() {
            buildGrid = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                const row = [];
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    row.push(BLOCK_TYPES.PATH); // Initialize all as paths for building
                }
                buildGrid.push(row);
            }
            // Set default player and winpad for new build levels
            player = { x: 1, y: 1 };
            end = { x: MAZE_WIDTH - 2, y: MAZE_HEIGHT - 2 };
            buildGrid[player.y][player.x] = { type: BLOCK_TYPES.PLAYER_START }; // Store as object
            buildGrid[end.y][end.x] = { type: BLOCK_TYPES.WINPAD }; // Store as object
        }

        // Binary Tree Algorithm for Maze Generation
        function generateMaze() {
            initMazeGrid(); // Start with a grid full of walls

            for (let y = 1; y < MAZE_HEIGHT - 1; y += 2) {
                for (let x = 1; x < MAZE_WIDTH - 1; x += 2) {
                    mazeGrid[y][x] = BLOCK_TYPES.PATH;

                    const neighbors = [];
                    if (y > 1) { neighbors.push({ nx: x, ny: y - 2, wx: x, wy: y - 1 }); }
                    if (x > 1) { neighbors.push({ nx: x - 2, ny: y, wx: x - 1, wy: y }); }

                    if (neighbors.length > 0) {
                        const chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                        mazeGrid[chosen.wy][chosen.wx] = BLOCK_TYPES.PATH;
                    }
                }
            }
        }

        // Generates a random block pattern
        function generateBlocks() {
            initMazeGrid(); // Start with a grid full of walls

            const pathPercentage = 0.6;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (Math.random() < pathPercentage) {
                        mazeGrid[y][x] = BLOCK_TYPES.PATH;
                    }
                }
            }
        }

        // Loads a level into the mazeGrid from the officialPlayableLevels array
        function loadOfficialLevel(levelIndex) {
            const level = officialPlayableLevels[levelIndex];
            // Ensure grid data is handled correctly, it could be a string or array
            mazeGrid = typeof level.grid === 'string' ? JSON.parse(level.grid) : level.grid;
            player = { ...level.playerStart }; // Reset player position
            end = { ...level.winpadEnd };
            currentLevelId = level.id;
            currentLevelName = level.name;
            currentLevelDifficulty = level.difficulty || 'N/A'; // Set difficulty for official levels
            currentLevelBrickReward = level.brickReward || 0; // Set brick reward for official levels
        }

        // Helper function to get a random valid path position
        function getRandomPathPosition() {
            let randX, randY;
            let foundValidPosition = false;
            while (!foundValidPosition) {
                randX = Math.floor(Math.random() * MAZE_WIDTH);
                randY = Math.floor(Math.random() * MAZE_HEIGHT);

                if (currentGameType === GAME_MODES.MAZE) {
                    // Ensure random positions are on paths in a generated maze
                    if (randX % 2 === 0) { randX = (randX === MAZE_WIDTH - 1) ? randX - 1 : randX + 1; }
                    if (randY % 2 === 0) { randY = (randY === MAZE_HEIGHT - 1) ? randY - 1 : randY + 1; }
                    randX = Math.min(Math.max(randX, 0), MAZE_WIDTH - 1);
                    randY = Math.min(Math.max(randY, 0), MAZE_HEIGHT - 1);
                }
                
                // Check if it's a path, considering complex block objects
                const block = mazeGrid[randY] ? mazeGrid[randY][randX] : BLOCK_TYPES.WALL;
                const blockType = typeof block === 'object' ? block.type : block;

                if (blockType === BLOCK_TYPES.PATH) { 
                    foundValidPosition = true;
                }
            }
            return { x: randX, y: randY };
        }

        // Draws elements on the mazeCanvas (for game play)
        function drawGame() {
            if (!mazeGrid || mazeGrid.length === 0) {
                initMazeGrid(); // Ensure mazeGrid is initialized
            }

            mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            mazeCtx.fillStyle = PATH_COLOR;
            mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const block = mazeGrid[y] ? mazeGrid[y][x] : BLOCK_TYPES.WALL; // Default to wall if undefined
                    const blockType = typeof block === 'object' ? block.type : block;
                    let color = PATH_COLOR;

                    switch (blockType) {
                        case BLOCK_TYPES.WALL:
                            color = WALL_COLOR;
                            break;
                        case BLOCK_TYPES.PLAYER_START:
                            color = PLAYER_COLOR; // Player start point is player color
                            break;
                        case BLOCK_TYPES.WINPAD:
                            color = END_COLOR;
                            break;
                        case BLOCK_TYPES.DAMAGING_BLOCK: // New damaging block
                            color = DAMAGING_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.PUSH_BLOCK:
                            color = PUSH_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.CUSTOM_BLOCK: // New custom block
                            // Try to get color from definition, fallback to default
                            color = customBlockDefinitions[block.customId]?.color || CUSTOM_BLOCK_DEFAULT_COLOR;
                            break;
                        case BLOCK_TYPES.PATH:
                        default:
                            color = PATH_COLOR;
                            break;
                    }
                    mazeCtx.fillStyle = color;
                    mazeCtx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            // Redraw player on top to ensure it is visible
            mazeCtx.fillStyle = PLAYER_COLOR;
            mazeCtx.fillRect(player.x * BLOCK_SIZE, player.y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            // Redraw end on top to ensure it is visible
            mazeCtx.fillStyle = END_COLOR;
            mazeCtx.fillRect(end.x * BLOCK_SIZE, end.y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        // Draws elements on the buildCanvas (for build mode)
        function drawBuild() {
            if (!buildGrid || buildGrid.length === 0) {
                initBuildGrid(); // Ensure buildGrid is initialized
            }

            buildCtx.clearRect(0, 0, buildCanvas.width, buildCanvas.height);
            buildCtx.fillStyle = PATH_COLOR;
            buildCtx.fillRect(0, 0, buildCanvas.width, buildCanvas.height);

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const block = buildGrid[y] ? buildGrid[y][x] : BLOCK_TYPES.PATH; // Default to path for build
                    const blockType = typeof block === 'object' ? block.type : block;
                    let color = PATH_COLOR;

                    switch (blockType) {
                        case BLOCK_TYPES.WALL:
                            color = WALL_COLOR;
                            break;
                        case BLOCK_TYPES.PLAYER_START:
                            color = PLAYER_COLOR;
                            break;
                        case BLOCK_TYPES.WINPAD:
                            color = END_COLOR;
                            break;
                        case BLOCK_TYPES.DAMAGING_BLOCK: // New damaging block
                            color = DAMAGING_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.PUSH_BLOCK:
                            color = PUSH_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.CUSTOM_BLOCK: // New custom block
                            // Try to get color from definition, fallback to default
                            color = customBlockDefinitions[block.customId]?.color || CUSTOM_BLOCK_DEFAULT_COLOR;
                            break;
                        case BLOCK_TYPES.PATH:
                        default:
                            color = PATH_COLOR;
                            break;
                    }
                    buildCtx.fillStyle = color;
                    buildCtx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            // Draw selection rectangle if it exists
            drawSelectionRect();
        }

        // Draws the current selection rectangle on the buildCanvas
        function drawSelectionRect() {
            if (currentSelectionRect) {
                const { x1, y1, x2, y2 } = currentSelectionRect;
                buildCtx.strokeStyle = '#FFFFFF'; // White border for selection
                buildCtx.lineWidth = 2;
                buildCtx.setLineDash([5, 5]); // Dashed line
                buildCtx.strokeRect(x1 * BLOCK_SIZE, y1 * BLOCK_SIZE, (x2 - x1 + 1) * BLOCK_SIZE, (y2 - y1 + 1) * BLOCK_SIZE);
                buildCtx.setLineDash([]); // Reset line dash
            }
        }

        // Handles player movement based on arrow keys or touch controls
        async function movePlayer(dx, dy) { // Made async to support custom block scripts
            if (gameWon) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check boundaries
            if (newX < 0 || newX >= MAZE_WIDTH || newY < 0 || newY >= MAZE_HEIGHT) {
                return; // Out of bounds
            }

            const targetBlock = mazeGrid[newY][newX];
            const targetBlockType = typeof targetBlock === 'object' ? targetBlock.type : targetBlock;

            // Handle Push Block
            if (targetBlockType === BLOCK_TYPES.PUSH_BLOCK) {
                const pushToX = newX + dx;
                const pushToY = newY + dy;

                // Check if the spot to push to is within bounds and is a PATH
                if (pushToX >= 0 && pushToX < MAZE_WIDTH &&
                    pushToY >= 0 && pushToY < MAZE_HEIGHT &&
                    (mazeGrid[pushToY][pushToX] === BLOCK_TYPES.PATH || (typeof mazeGrid[pushToY][pushToX] === 'object' && mazeGrid[pushToY][pushToX].type === BLOCK_TYPES.PATH))) {
                    
                    // Move the push block
                    mazeGrid[pushToY][pushToX] = { type: BLOCK_TYPES.PUSH_BLOCK }; // Ensure it's stored as an object
                    mazeGrid[newY][newX] = BLOCK_TYPES.PATH; // Clear old push block position
                    
                    // Move player
                    player.x = newX;
                    player.y = newY;
                    drawGame();
                    checkWinCondition();
                    return; // Movement handled
                } else {
                    // Cannot push, treat as a wall for player movement
                    return;
                }
            }

            // Cannot move onto a wall
            if (targetBlockType === BLOCK_TYPES.WALL) {
                return;
            }

            // Move player
            player.x = newX;
            player.y = newY;
            drawGame();
            checkWinCondition(); // Check win condition after player moves

            // Handle Damaging Block
            if (targetBlockType === BLOCK_TYPES.DAMAGING_BLOCK) {
                takeDamage(1);
            }

            // Handle Custom Block
            if (targetBlockType === BLOCK_TYPES.CUSTOM_BLOCK) {
                await executeCustomBlockScript(targetBlock, { x: newX, y: newY });
            }
        }

        // Executes the script of a custom block
        async function executeCustomBlockScript(blockData, blockCoords) {
            const definition = customBlockDefinitions[blockData.customId];
            if (!definition || !definition.script || !Array.isArray(definition.script)) {
                console.warn(`Custom block definition or script not found for ID: ${blockData.customId}`);
                return;
            }

            for (const action of definition.script) {
                if (currentHealth <= 0) break; // Stop script if player dies
                switch (action.type) {
                    case 'wait':
                        if (action.params && typeof action.params.duration === 'number') {
                            await new Promise(resolve => setTimeout(resolve, action.params.duration));
                        }
                        break;
                    case 'damagePlayer':
                        if (action.params && typeof action.params.amount === 'number') {
                            takeDamage(action.params.amount);
                        }
                        break;
                    case 'message':
                        if (action.params && typeof action.params.text === 'string') {
                            messageBox.textContent = action.params.text;
                        }
                        break;
                    case 'teleportPlayer':
                        if (action.params && typeof action.params.targetX === 'number' && typeof action.params.targetY === 'number') {
                            player.x = action.params.targetX;
                            player.y = action.params.targetY;
                            drawGame();
                            checkWinCondition();
                        }
                        break;
                    case 'changeBlockType':
                        if (action.params && (typeof action.params.targetX === 'number' || action.params.targetX === 'self') && (typeof action.params.targetY === 'number' || action.params.targetY === 'self') && typeof action.params.newType === 'number') {
                            let targetX = action.params.targetX === 'self' ? blockCoords.x : action.params.targetX;
                            let targetY = action.params.targetY === 'self' ? blockCoords.y : action.params.targetY;

                            if (targetX >= 0 && targetX < MAZE_WIDTH && targetY >= 0 && targetY < MAZE_HEIGHT) {
                                mazeGrid[targetY][targetX] = action.params.newType;
                                drawGame();
                            }
                        }
                        break;
                    case 'loop':
                        if (action.params && typeof action.params.count === 'number' && Array.isArray(action.params.actions)) {
                            for (let i = 0; i < action.params.count; i++) {
                                // Recursively execute nested actions
                                for (const nestedAction of action.params.actions) {
                                    if (currentHealth <= 0) break; // Stop nested loop if player dies
                                    switch (nestedAction.type) {
                                        case 'wait':
                                            if (nestedAction.params && typeof nestedAction.params.duration === 'number') {
                                                await new Promise(resolve => setTimeout(resolve, nestedAction.params.duration));
                                            }
                                            break;
                                        case 'damagePlayer':
                                            if (nestedAction.params && typeof nestedAction.params.amount === 'number') {
                                                takeDamage(nestedAction.params.amount);
                                            }
                                            break;
                                        case 'message':
                                            if (nestedAction.params && typeof nestedAction.params.text === 'string') {
                                                messageBox.textContent = nestedAction.params.text;
                                            }
                                            break;
                                        case 'teleportPlayer':
                                            if (nestedAction.params && typeof nestedAction.params.targetX === 'number' && typeof nestedAction.params.targetY === 'number') {
                                                player.x = nestedAction.params.targetX;
                                                player.y = nestedAction.params.targetY;
                                                drawGame();
                                                checkWinCondition();
                                            }
                                            break;
                                        case 'changeBlockType':
                                            if (nestedAction.params && (typeof nestedAction.params.targetX === 'number' || nestedAction.params.targetX === 'self') && (typeof nestedAction.params.targetY === 'number' || nestedAction.params.targetY === 'self') && typeof nestedAction.params.newType === 'number') {
                                                let targetX = nestedAction.params.targetX === 'self' ? blockCoords.x : nestedAction.params.targetX;
                                                let targetY = nestedAction.params.targetY === 'self' ? blockCoords.y : nestedAction.params.targetY;

                                                if (targetX >= 0 && targetX < MAZE_WIDTH && targetY >= 0 && targetY < MAZE_HEIGHT) {
                                                    mazeGrid[targetY][targetX] = nestedAction.params.newType;
                                                    drawGame();
                                                }
                                            }
                                            break;
                                        default:
                                            console.warn(`Unknown nested script action type: ${nestedAction.type}`);
                                    }
                                }
                            }
                        }
                        break;
                    default:
                        console.warn(`Unknown script action type: ${action.type}`);
                }
            }
        }

        // Updates the player's health and checks for game over
        function takeDamage(amount) {
            currentHealth -= amount;
            if (currentHealth < 0) currentHealth = 0;
            updateHealthDisplay();
            if (currentHealth <= 0) {
                gameWon = true; // Set gameWon to true to stop further movement
                messageBox.textContent = "Game Over! You ran out of health.";
                // Optionally, restart level or go to main menu
                setTimeout(() => {
                    showScreen('startScreen');
                }, 3000);
            }
        }

        // Updates the health display in the UI
        function updateHealthDisplay() {
            if (playerHealthDisplay) {
                playerHealthDisplay.textContent = `Health: ❤️ ${currentHealth}`;
            }
        }


        // Checks if the player has reached the end point
        function checkWinCondition() {
            if (currentHealth <= 0) { // If health is 0, it's already game over
                gameWon = true;
                messageBox.textContent = "Game Over! You ran out of health.";
                return;
            }

            if (player.x === end.x && player.y === end.y) {
                gameWon = true;
                messageBox.textContent = "Congratulations! You reached the end!";
                stopLevelTimerAndSubmitScore(); // New: Submit score on win
                addBrick(currentLevelBrickReward); // New: Give player bricks based on level setting
            } else {
                const modeName = currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1).replace('_', ' ');
                let displayLevelName = currentLevelName;
                let difficultyDisplay = '';
                let bricksDisplay = '';

                if (currentLevelDifficulty && currentLevelDifficulty !== 'N/A') {
                    difficultyDisplay = ` (${currentLevelDifficulty.replace('_', ' ')})`; // Replace underscore for display
                }
                if (currentLevelBrickReward > 0) {
                    bricksDisplay = ` 🧱 ${currentLevelBrickReward}`;
                }

                messageBox.textContent = `Mode: ${modeName} (${displayLevelName}${difficultyDisplay}${bricksDisplay}) | Reach the green pad!`;
            }
        }

        // Starts the timer for level completion
        function startLevelTimer() {
            gameStartTime = Date.now();
        }

        // Stops the timer and submits the score to the leaderboard
        async function stopLevelTimerAndSubmitScore() {
            if (!currentLevelId || !window.userId || !window.db) {
                console.warn("Cannot submit score: Missing level ID, user ID, or database instance.");
                messageBox.textContent = "Cannot submit score: Firebase not fully initialized or user not authenticated.";
                return;
            }

            const timeTaken = Date.now() - gameStartTime; // Time in milliseconds

            try {
                // We're now saving the player's current total bricks to the leaderboard.
                // This is a simplified approach for a "bricks leaderboard" as requested.
                // For a more robust system, you might have a separate 'player_scores' collection
                // that tracks each player's highest brick count, updated on completion.
                // For this request, we'll just save the current brick count with the level completion.
                const leaderboardRef = collection(window.db, `artifacts/${window.__app_id}/public/data/leaderboard`);
                
                // To make the leaderboard show "amount of bricks", we need to store the player's latest total brick count.
                // This will be stored in a 'user_bricks_scores' collection.
                const userBricksScoreRef = doc(window.db, `artifacts/${window.__app_id}/public/data/user_bricks_scores`, window.userId);

                await setDoc(userBricksScoreRef, {
                    playerName: currentPlayerName,
                    userId: window.userId,
                    bricks: playerBricks, // This is the key for the new leaderboard
                    lastUpdated: new Date()
                }, { merge: true }); // Use merge to update existing document

                console.log(`Player ${currentPlayerName}'s total bricks (${playerBricks}) updated for leaderboard.`);
                messageBox.textContent += ` Your time: ${formatTime(timeTaken)}!`;
            } catch (e) {
                console.error("Error submitting score:", e);
                messageBox.textContent = `Error submitting score: ${e.message}. Check console for details.`;
            }
        }

        // Formats milliseconds into a readable time string
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = ms % 1000;

            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        // Adds a specified number of bricks to the player's count
        async function addBrick(amount = 1) { // Default to 1 if amount not specified
            if (!window.userId || !window.db) {
                console.warn("Cannot add brick: User ID or database not available.");
                messageBox.textContent = "Cannot add brick: Firebase not fully initialized or user not authenticated.";
                return;
            }

            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                const docSnap = await getDoc(userProfileRef);

                if (docSnap.exists()) {
                    playerBricks = docSnap.data().bricks || 0;
                } else {
                    playerBricks = 0;
                }
                playerBricks += amount; // Increment brick count by amount
                await setDoc(userProfileRef, { bricks: playerBricks }, { merge: true });
                updateBricksDisplay();
                if (amount > 0) {
                    messageBox.textContent += ` You earned ${amount} 🧱!`;
                }
                console.log(`Player ${currentPlayerName} now has ${playerBricks} bricks.`);
            } catch (e) {
                console.error("Error adding brick:", e);
                messageBox.textContent = `Error adding brick: ${e.message}. Check console for details.`;
            }
        }

        // Fetches player's bricks from Firestore
        async function fetchPlayerBricks() {
            if (!window.userId || !window.db) {
                playerBricks = 0; // Reset if no user/db
                updateBricksDisplay();
                console.warn("Cannot fetch player bricks: Firebase not fully initialized or user not authenticated.");
                return;
            }
            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                const docSnap = await getDoc(userProfileRef);
                if (docSnap.exists()) {
                    playerBricks = docSnap.data().bricks || 0;
                } else {
                    playerBricks = 0;
                }
                updateBricksDisplay();
            }
            catch (e) {
                console.error("Error fetching player bricks:", e);
                playerBricks = 0; // Default to 0 on error
                updateBricksDisplay();
                messageBox.textContent = `Error fetching bricks: ${e.message}. Check console for details.`;
            }
        }

        // Updates the bricks display in the UI
        function updateBricksDisplay() {
            if (playerBricksDisplay) { // Ensure element exists before updating
                playerBricksDisplay.textContent = `Bricks: 🧱 ${playerBricks}`;
            }
        }

        // Saves customization settings to Firestore
        async function saveCustomization() {
            if (!window.userId || !window.db) {
                console.warn("Cannot save customization: User ID or database not available.");
                return;
            }
            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                await setDoc(userProfileRef, {
                    playerColor: PLAYER_COLOR,
                    wallColor: WALL_COLOR,
                    pathColor: PATH_COLOR
                }, { merge: true });
                console.log("Customization saved successfully!");
            } catch (e) {
                console.error("Error saving customization:", e);
                messageBox.textContent = `Error saving customization: ${e.message}. Check console for details.`;
            }
        }

        // Load user profile (player name, bricks, and customization)
        async function loadUserProfile() {
            if (!window.userId || !window.db) {
                console.warn("Cannot load user profile: User ID or database not available.");
                // Attempt to load player name from localStorage even if Firebase is not ready
                const storedPlayerName = localStorage.getItem('playerName');
                if (storedPlayerName) {
                    currentPlayerName = storedPlayerName;
                    if (loginButton) { // Check if loginButton is initialized
                        loginButton.textContent = "Logout";
                        loginButton.classList.add('logged-in');
                    }
                }
                updateUserIdDisplay();
                updateBricksDisplay();
                if (mazeCtx) drawGame(); // Only draw if context is available
                if (buildCtx) drawBuild(); // Only draw if context is available
                return;
            }
            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                const docSnap = await getDoc(userProfileRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    currentPlayerName = data.playerName || localStorage.getItem('playerName') || "Anonymous";
                    playerBricks = data.bricks || 0;
                    PLAYER_COLOR = data.playerColor || '#0000FF'; // Default to blue
                    WALL_COLOR = data.wallColor || '#000000';
                    PATH_COLOR = data.pathColor || '#f0f0f0';

                    // Update color pickers to reflect loaded colors
                    if (playerColorPicker) playerColorPicker.value = PLAYER_COLOR;
                    if (wallColorPicker) wallColorPicker.value = WALL_COLOR;
                    if (pathColorPicker) pathColorPicker.value = PATH_COLOR;

                    if (currentPlayerName !== "Anonymous") {
                        if (loginButton) { // Check if loginButton is initialized
                            loginButton.textContent = "Logout";
                            loginButton.classList.add('logged-in');
                        }
                    }
                } else {
                    // If no profile exists in Firestore, check localStorage
                    const storedPlayerName = localStorage.getItem('playerName');
                    if (storedPlayerName) {
                        currentPlayerName = storedPlayerName;
                        if (loginButton) { // Check if loginButton is initialized
                            loginButton.textContent = "Logout";
                            loginButton.classList.add('logged-in');
                        }
                    } else {
                        currentPlayerName = "Anonymous";
                    }
                    playerBricks = 0;
                    // Reset colors to default if no profile exists
                    PLAYER_COLOR = '#0000FF'; // Default to blue
                    WALL_COLOR = '#000000';
                    PATH_COLOR = '#f0f0f0';
                    if (playerColorPicker) playerColorPicker.value = PLAYER_COLOR;
                    if (wallColorPicker) wallColorPicker.value = WALL_COLOR;
                    if (pathColorPicker) pathColorPicker.value = PATH_COLOR;
                }
                updateUserIdDisplay();
                updateBricksDisplay();
                if (mazeCtx) drawGame(); // Redraw game with loaded colors
                if (buildCtx) drawBuild(); // Redraw build canvas with loaded colors
            } catch (e) {
                console.error("Error loading user profile:", e);
                // Fallback to localStorage and defaults on error
                const storedPlayerName = localStorage.getItem('playerName');
                if (storedPlayerName) {
                    currentPlayerName = storedPlayerName;
                    if (loginButton) loginButton.textContent = "Logout";
                } else {
                    currentPlayerName = "Anonymous";
                }
                playerBricks = 0;
                PLAYER_COLOR = '#0000FF'; // Fallback to default blue
                WALL_COLOR = '#000000'; // Fallback to default
                PATH_COLOR = '#f0f0f0'; // Fallback to default
                if (playerColorPicker) playerColorPicker.value = PLAYER_COLOR;
                if (wallColorPicker) wallColorPicker.value = WALL_COLOR;
                if (pathColorPicker) pathColorPicker.value = PATH_COLOR;
                updateUserIdDisplay();
                updateBricksDisplay();
                if (mazeCtx) drawGame();
                if (buildCtx) drawBuild();
                if (messageBox) messageBox.textContent = `Error loading profile: ${e.message}. Check console for details.`;
            }
        }


        // Initializes the game state based on the current mode
        function initializeGame() {
            gameWon = false;
            currentHealth = PLAYER_MAX_HEALTH; // Reset health for new game
            updateHealthDisplay(); // Update health display
            currentLevelId = null;
            currentLevelName = '';
            currentLevelDifficulty = ''; // Reset difficulty for new game
            currentLevelBrickReward = 0; // Reset brick reward for new game

            if (currentGameType === GAME_MODES.LEVEL) {
                if (officialPlayableLevels.length === 0) {
                    if (messageBox) messageBox.textContent = `No official levels found. Play a random maze or build your own!`;
                    if (nextLevelButton) nextLevelButton.style.display = 'none';
                    if (editCurrentLevelButton) editCurrentLevelButton.style.display = 'none'; // Hide edit button for official levels
                    if (mazeCtx && mazeCanvas) mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height); // Clear canvas
                    return; // Don't start game if no levels
                }
                loadOfficialLevel(currentLevelIndex); // Loads from officialPlayableLevels
                if (editCurrentLevelButton) editCurrentLevelButton.style.display = 'none'; // Hide edit button for official levels
            } else if (currentGameType === GAME_MODES.MAZE) {
                generateMaze();
                player = getRandomPathPosition();
                do {
                    end = getRandomPathPosition();
                } while (player.x === end.x && player.y === end.y);
                currentLevelId = `random-maze-${Date.now()}`;
                currentLevelName = "Random Maze";
                currentLevelDifficulty = 'random'; // Assign a difficulty for random levels
                currentLevelBrickReward = 1; // Default bricks for random maze
                if (editCurrentLevelButton) editCurrentLevelButton.style.display = 'block'; // Show edit button for random modes
            } else if (currentGameType === GAME_MODES.BLOCKS) {
                generateBlocks();
                player = getRandomPathPosition();
                do {
                    end = getRandomPathPosition();
                } while (player.x === end.x && player.y === end.y);
                currentLevelId = `random-blocks-${Date.now()}`;
                currentLevelName = "Random Blocks";
                currentLevelDifficulty = 'random'; // Assign a difficulty for random levels
                currentLevelBrickReward = 1; // Default bricks for random blocks
                if (editCurrentLevelButton) editCurrentLevelButton.style.display = 'block'; // Show edit button for random modes
            } else if (currentGameType === GAME_MODES.BUILD) {
                if (!buildGrid || buildGrid.length === 0 || buildGrid[0].length === 0) {
                    initBuildGrid();
                }
                if (buildMessageBox) buildMessageBox.textContent = "Click to place/remove blocks!";
                updatePlayerAndEndFromBuildGrid();
                if (editCurrentLevelButton) editCurrentLevelButton.style.display = 'none'; // Hide edit button in build mode
            } else if (currentGameType === GAME_MODES.SAVED_LEVEL || currentGameType === GAME_MODES.COMMUNITY_LEVEL) {
                // mazeGrid, player, end, currentLevelId, currentLevelName, currentLevelDifficulty, currentLevelBrickReward are already set by playSavedLevel/playCommunityLevel
                if (editCurrentLevelButton) editCurrentLevelButton.style.display = 'block'; // Show edit button for saved/community levels
            }
            
            if (nextLevelButton) nextLevelButton.style.display = (currentGameType === GAME_MODES.LEVEL && officialPlayableLevels.length > 0) ? 'block' : 'none';

            if (currentGameType !== GAME_MODES.BUILD) {
                startLevelTimer(); // Start timer for playable levels
                checkWinCondition();
                if (mazeCtx) drawGame();
            } else {
                if (buildCtx) drawBuild();
            }
        }

        // Adjusts canvas size and block size based on container width and window height
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            if (!container) return; // Exit if container is not found

            const containerWidth = container.clientWidth - 60;

            BLOCK_SIZE = Math.floor(Math.min(containerWidth / MAZE_WIDTH, (window.innerHeight * 0.6) / MAZE_HEIGHT));
            BLOCK_SIZE = Math.max(BLOCK_SIZE, 8);
            BLOCK_SIZE = Math.min(BLOCK_SIZE, 15);

            if (mazeCanvas) {
                mazeCanvas.width = MAZE_WIDTH * BLOCK_SIZE;
                mazeCanvas.height = MAZE_HEIGHT * BLOCK_SIZE;
            }
            if (buildCanvas) {
                buildCanvas.width = MAZE_WIDTH * BLOCK_SIZE;
                buildCanvas.height = MAZE_HEIGHT * BLOCK_SIZE;
            }

            // Redraw content after resizing
            if (startScreen && startScreen.classList.contains('active')) {
                // No canvas drawing on start screen
            } else if (gamePlayArea && gamePlayArea.classList.contains('active')) {
                if (mazeCtx) drawGame();
            } else if (buildModeArea && buildModeArea.classList.contains('active')) {
                if (buildCtx) drawBuild();
            }
            positionTouchControls(); // Reposition touch controls on resize
        }

        // Function to switch between different main screens
        let currentActiveScreen = 'startScreen';
        function showScreen(screenId) {
            if (startScreen) startScreen.classList.remove('active');
            if (gamePlayArea) gamePlayArea.classList.remove('active');
            if (buildModeArea) buildModeArea.classList.remove('active'); // Fixed typo here

            currentActiveScreen = screenId;

            if (screenId === 'startScreen') {
                if (startScreen) startScreen.classList.add('active');
                if (infoButton) infoButton.style.display = 'block';
                if (loginButton) loginButton.style.display = 'block';
                if (guidesButton) guidesButton.style.display = 'block'; // Show guides button
            } else if (screenId === 'gamePlayArea') {
                if (gamePlayArea) gamePlayArea.classList.add('active');
                if (infoButton) infoButton.style.display = 'block';
                if (loginButton) loginButton.style.display = 'block';
                if (guidesButton) guidesButton.style.display = 'block'; // Show guides button
                initializeGame();
            } else if (screenId === 'buildModeArea') {
                if (buildModeArea) buildModeArea.classList.add('active'); 
                if (infoButton) infoButton.style.display = 'block';
                if (loginButton) loginButton.style.display = 'block';
                if (guidesButton) guidesButton.style.display = 'block'; // Show guides button
                initializeGame();
                selectBuildTool(BLOCK_TYPES.WALL); // Default to Wall tool
            }
            resizeCanvas(); // Call resize after showing screen to ensure correct dimensions
        }

        // Handle clicks on the build canvas
        function handleBuildCanvasInteraction(event) {
            if (!buildCanvas || !buildCtx) return; // Ensure canvas is available

            const rect = buildCanvas.getBoundingClientRect();
            const scaleX = buildCanvas.width / rect.width;
            const scaleY = buildCanvas.height / rect.height;

            const x = Math.floor((event.clientX - rect.left) * scaleX / BLOCK_SIZE);
            const y = Math.floor((event.clientY - rect.top) * scaleY / BLOCK_SIZE);

            if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) {
                return; // Out of bounds
            }

            if (currentBuildTool === 'selection') {
                if (event.type === 'mousedown') {
                    isDrawing = true;
                    selectionStartPoint = { x, y };
                    selectionEndPoint = { x, y };
                    currentSelectionRect = { x1: x, y1: y, x2: x, y2: y };
                } else if (event.type === 'mousemove' && isDrawing) {
                    selectionEndPoint = { x, y };
                    // Normalize selection rectangle coordinates
                    currentSelectionRect = {
                        x1: Math.min(selectionStartPoint.x, selectionEndPoint.x),
                        y1: Math.min(selectionStartPoint.y, selectionEndPoint.y),
                        x2: Math.max(selectionStartPoint.x, selectionEndPoint.x),
                        y2: Math.max(selectionStartPoint.y, selectionEndPoint.y)
                    };
                    drawBuild(); // Redraw with live selection
                } else if (event.type === 'mouseup') {
                    isDrawing = false;
                    selectionEndPoint = { x, y };
                    currentSelectionRect = {
                        x1: Math.min(selectionStartPoint.x, selectionEndPoint.x),
                        y1: Math.min(selectionStartPoint.y, selectionEndPoint.y),
                        x2: Math.max(selectionStartPoint.x, selectionEndPoint.x),
                        y2: Math.max(selectionStartPoint.y, selectionEndPoint.y)
                    };
                    drawBuild(); // Final redraw with selection
                    if (buildMessageBox) buildMessageBox.textContent = `Selected area from (${currentSelectionRect.x1},${currentSelectionRect.y1}) to (${currentSelectionRect.x2},${currentSelectionRect.y2}).`;
                }
            } else { // Handle drawing tools
                // Only proceed if mouse button is down for drawing, or if it's a single click for player/winpad
                if (event.buttons !== 1 && event.type === 'mousemove') return; // Not dragging with left click
                if (event.type === 'mousedown') isDrawing = true;
                if (event.type === 'mouseup') isDrawing = false;
                if (event.type === 'mousemove' && !isDrawing) return;

                let currentBlock = buildGrid[y][x];
                let currentBlockType = typeof currentBlock === 'object' ? currentBlock.type : currentBlock;

                if (currentBuildTool === BLOCK_TYPES.PLAYER_START) {
                    if (event.type === 'mousedown') { // Only place player start on mousedown
                        for (let row = 0; row < MAZE_HEIGHT; row++) {
                            for (let col = 0; col < MAZE_WIDTH; col++) {
                                const block = buildGrid[row][col];
                                if (typeof block === 'object' && block.type === BLOCK_TYPES.PLAYER_START) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH; // Change old player start to path
                                } else if (block === BLOCK_TYPES.PLAYER_START) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH;
                                }
                            }
                        }
                        player = { x, y };
                        buildGrid[y][x] = { type: BLOCK_TYPES.PLAYER_START }; // Store as object for consistency
                        drawBuild();
                    }
                } else if (currentBuildTool === BLOCK_TYPES.WINPAD) {
                    if (event.type === 'mousedown') { // Only place winpad on mousedown
                        for (let row = 0; row < MAZE_HEIGHT; row++) {
                            for (let col = 0; col < MAZE_WIDTH; col++) {
                                const block = buildGrid[row][col];
                                if (typeof block === 'object' && block.type === BLOCK_TYPES.WINPAD) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH; // Change old winpad to path
                                } else if (block === BLOCK_TYPES.WINPAD) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH;
                                }
                            }
                        }
                        end = { x, y };
                        buildGrid[y][x] = { type: BLOCK_TYPES.WINPAD }; // Store as object for consistency
                        drawBuild();
                    }
                } else if (currentBuildTool === BLOCK_TYPES.CUSTOM_BLOCK) {
                    if (event.type === 'mousedown') {
                        if (!currentSelectedCustomBlockId) {
                            if (buildMessageBox) buildMessageBox.textContent = "Please select a Custom Block Definition first!";
                            showCustomBlockEditorModal(); // Open editor to select/create
                            return;
                        }
                        // Place the custom block, linking it to its definition
                        buildGrid[y][x] = { type: BLOCK_TYPES.CUSTOM_BLOCK, customId: currentSelectedCustomBlockId };
                        if (buildMessageBox) buildMessageBox.textContent = `Placed Custom Block: ${currentSelectedCustomBlockId}`;
                        drawBuild();
                    }
                } else {
                    // For other blocks (Wall, Path, Damaging, Push), and Eraser (which sets to PATH)
                    const targetTool = (currentBuildTool === 'eraser') ? BLOCK_TYPES.PATH : currentBuildTool;

                    // Only change the block if the current block type is different from the target tool
                    // and it's not a player/winpad or the current tool is player/winpad
                    if (currentBlockType !== targetTool || (targetTool === BLOCK_TYPES.PLAYER_START || targetTool === BLOCK_TYPES.WINPAD)) {
                        buildGrid[y][x] = targetTool; // Set to current tool
                    }
                    // If player or end was on this spot and it's now PATH, reset their positions
                    if (player.x === x && player.y === y && (buildGrid[y][x] === BLOCK_TYPES.PATH || (typeof buildGrid[y][x] === 'object' && buildGrid[y][x].type === BLOCK_TYPES.PATH))) {
                        player = { x: -1, y: -1 }; // Invalidate player position
                        if (buildMessageBox) buildMessageBox.textContent = "Player Start removed! Place a new one.";
                    }
                    if (end.x === x && end.y === y && (buildGrid[y][x] === BLOCK_TYPES.PATH || (typeof buildGrid[y][x] === 'object' && buildGrid[y][x].type === BLOCK_TYPES.PATH))) {
                        end = { x: -1, y: -1 }; // Invalidate end position
                        if (buildMessageBox) buildMessageBox.textContent = "Win Pad removed! Place a new one.";
                    }
                    drawBuild();
                }
            }
        }

        // Function to update player and end positions based on buildGrid (e.g., after loading)
        function updatePlayerAndEndFromBuildGrid() {
            let foundPlayer = false;
            let foundEnd = false;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const block = buildGrid[y][x];
                    const blockType = typeof block === 'object' ? block.type : block;

                    if (blockType === BLOCK_TYPES.PLAYER_START) {
                        player = { x, y };
                        foundPlayer = true;
                    } else if (blockType === BLOCK_TYPES.WINPAD) {
                        end = { x, y };
                        foundEnd = true;
                    }
                }
            }
            if (!foundPlayer) player = { x: -1, y: -1 };
            if (!foundEnd) end = { x: -1, y: -1 };
        }

        // Function to set the active build tool
        function selectBuildTool(toolType) {
            // Remove active-tool class from all buttons
            document.querySelectorAll('.build-tools button').forEach(btn => {
                btn.classList.remove('active-tool');
            });

            // Update currentBuildTool and lastSelectedDrawingTool
            if (toolType === 'selection') { // Special case for selection mode
                currentBuildTool = 'selection'; // Use a string to represent selection mode
                if (buildMessageBox) buildMessageBox.textContent = "Tool: Selection. Click and drag to select an area.";
                // Show selection action buttons, hide drawing tools
                if (selectionActionsContainer) selectionActionsContainer.style.display = 'flex';
                if (drawingToolsContainer) drawingToolsContainer.style.display = 'none';
                clearSelection(); // Clear any existing selection when entering selection mode
            } else { // It's a drawing block type
                currentBuildTool = toolType;
                lastSelectedDrawingTool = toolType; // Store the actual block type
                if (buildMessageBox) {
                    const toolName = Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === toolType)?.replace('_', ' ') || 'Unknown';
                    buildMessageBox.textContent = `Tool: ${toolName}`;
                }
                // Hide selection action buttons, show drawing tools
                if (selectionActionsContainer) selectionActionsContainer.style.display = 'none';
                if (drawingToolsContainer) drawingToolsContainer.style.display = 'flex';
                clearSelection(); // Clear any existing selection when switching to drawing mode
            }

            // Highlight the active tool button
            switch (currentBuildTool) {
                case BLOCK_TYPES.WALL: if (toolWall) toolWall.classList.add('active-tool'); break;
                case 'eraser': if (toolEraser) toolEraser.classList.add('active-tool'); break; // Highlight eraser
                case BLOCK_TYPES.PATH: if (toolPath) toolPath.classList.add('active-tool'); break;
                case BLOCK_TYPES.PLAYER_START: if (toolPlayer) toolPlayer.classList.add('active-tool'); break;
                case BLOCK_TYPES.WINPAD: if (toolWinpad) toolWinpad.classList.add('active-tool'); break;
                case BLOCK_TYPES.DAMAGING_BLOCK: if (toolDamagingBlock) toolDamagingBlock.classList.add('active-tool'); break;
                case BLOCK_TYPES.PUSH_BLOCK: if (toolPushBlock) toolPushBlock.classList.add('active-tool'); break;
                case BLOCK_TYPES.CUSTOM_BLOCK: if (toolCustomBlock) toolCustomBlock.classList.add('active-tool'); break;
                case 'selection': if (toolSelection) toolSelection.classList.add('active-tool'); break; // Highlight selection button
            }
        }

        // Fills the current selection with a specified block type
        function fillSelection(fillType) {
            if (!currentSelectionRect) {
                if (buildMessageBox) buildMessageBox.textContent = "No area selected to fill.";
                return;
            }

            const { x1, y1, x2, y2 } = currentSelectionRect;
            for (let y = y1; y <= y2; y++) {
                for (let x = x1; x <= x2; x++) {
                    // Handle player/winpad replacement
                    if (player.x === x && player.y === y && fillType !== BLOCK_TYPES.PLAYER_START) {
                        player = { x: -1, y: -1 }; // Invalidate player position
                        if (buildMessageBox) buildMessageBox.textContent = "Player Start removed! Place a new one.";
                    }
                    if (end.x === x && end.y === y && fillType !== BLOCK_TYPES.WINPAD) {
                        end = { x: -1, y: -1 }; // Invalidate end position
                        if (buildMessageBox) buildMessageBox.textContent = "Win Pad removed! Place a new one.";
                    }
                    // If filling with a custom block, ensure to use the selected customId
                    if (fillType === BLOCK_TYPES.CUSTOM_BLOCK) {
                        if (!currentSelectedCustomBlockId) {
                             if (buildMessageBox) buildMessageBox.textContent = "Please select a Custom Block Definition first!";
                             return;
                        }
                        buildGrid[y][x] = { type: BLOCK_TYPES.CUSTOM_BLOCK, customId: currentSelectedCustomBlockId };
                    } else {
                        buildGrid[y][x] = fillType;
                    }
                }
            }
            drawBuild();
            if (buildMessageBox) {
                const fillTypeName = Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === fillType)?.replace('_', ' ') || 'Unknown';
                buildMessageBox.textContent = `Selected area filled with ${fillTypeName}.`;
            }
            clearSelection(); // Clear selection after filling
        }

        // Clears the current selection (fills with PATH)
        function clearSelection() {
            selectionStartPoint = null;
            selectionEndPoint = null;
            currentSelectionRect = null;
            drawBuild(); // Redraw to remove selection rectangle
            if (buildMessageBox) buildMessageBox.textContent = "Selection cleared.";
        }


        // Functions to show/hide modals
        function showModal(modalOverlay) {
            if (modalOverlay) modalOverlay.classList.add('show');
        }

        function hideModal(modalOverlay) {
            if (modalOverlay) modalOverlay.classList.remove('show');
        }

        function hideAllModals() {
            hideModal(infoModalOverlay);
            // Removed hideModal(guidesModalOverlay);
            hideModal(customizationModalOverlay);
            hideModal(menuModalOverlay);
            hideModal(loginModalOverlay);
            hideModal(communityLevelsModalOverlay);
            hideModal(leaderboardModalOverlay);
            hideModal(customBlockEditorModalOverlay); // Hide custom block editor
        }

        // --- Simulated Login Functions ---
        async function handleLogin() {
            const playerName = playerNameInput.value.trim();
            const password = passwordInput.value.trim(); // Password is not used for auth, just for input field

            // Validation checks
            if (playerName.length < 3) {
                if (messageBox) messageBox.textContent = "Player Name must be at least 3 characters long.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                return;
            }

            if (password.length < 6) {
                if (messageBox) messageBox.textContent = "Password must be at least 6 characters long.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                return;
            }

            if (playerName) {
                currentPlayerName = playerName;
                localStorage.setItem('playerName', currentPlayerName); // Save player name to localStorage
                if (loginButton) {
                    loginButton.textContent = "Logout";
                    loginButton.classList.add('logged-in');
                }
                updateUserIdDisplay();
                hideModal(loginModalOverlay);
                loadMyLevels(); // Refresh levels for the "logged in" user
                fetchPlayerBricks(); // Fetch bricks on login
                loadCustomBlockDefinitionsFromFirestore(); // Load custom block definitions on login

                // Save player name to Firestore profile
                if (window.userId && window.db) {
                    try {
                        const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                        await setDoc(userProfileRef, { playerName: currentPlayerName }, { merge: true });
                        console.log("Player name saved to profile.");
                    } catch (e) {
                        console.error("Error saving player name to profile:", e);
                        if (messageBox) messageBox.textContent = `Error saving player name: ${e.message}. Check console for details.`;
                    }
                }

            } else {
                // This else block might be redundant due to the new validation, but kept for safety.
                if (messageBox) messageBox.textContent = "Please enter a player name.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000); // Clear message after 3 seconds
            }
        }

        function handleLogout() {
            currentPlayerName = "Anonymous";
            localStorage.removeItem('playerName'); // Remove player name from localStorage
            if (loginButton) {
                loginButton.textContent = "Login";
                loginButton.classList.remove('logged-in');
            }
            updateUserIdDisplay();
            if (myLevelsList) myLevelsList.innerHTML = "<div>No levels loaded.</div>"; // Clear levels on logout
            playerBricks = 0; // Reset bricks on logout
            updateBricksDisplay();
            customBlockDefinitions = {}; // Clear custom block definitions on logout
            renderCustomBlockDefinitionsList(); // Clear list
        }

        function updateUserIdDisplay() {
            if (userIdDisplay) { // Added null check
                if (currentPlayerName !== "Anonymous") {
                    userIdDisplay.textContent = `Player: ${currentPlayerName} (ID: ${window.userId})`;
                } else {
                    userIdDisplay.textContent = `User ID: ${window.userId} (Anonymous)`;
                }
            }
        }


        // --- Firebase Firestore Functions ---
        async function saveLevel() {
            if (!window.userId || !window.db) {
                if (buildMessageBox) buildMessageBox.textContent = "Error: Firebase not fully initialized or user not authenticated to save level.";
                return;
            }
            if (player.x === -1 || end.x === -1) {
                if (buildMessageBox) buildMessageBox.textContent = "Please place both Player Start and Win Pad before saving!";
                return;
            }

            const levelName = prompt("Enter a name for your level (max 30 characters):");
            if (!levelName) {
                if (buildMessageBox) buildMessageBox.textContent = "Level save cancelled.";
                return;
            }
            if (levelName.length > 30) {
                if (buildMessageBox) buildMessageBox.textContent = "Level name exceeds 30 characters. Please shorten it.";
                return;
            }

            let levelOrder = prompt("Enter an optional order number for this level (e.g., 1, 2, 3...). Leave blank if no specific order is needed.");
            levelOrder = levelOrder ? parseInt(levelOrder) : null;

            if (levelOrder !== null && (isNaN(levelOrder) || levelOrder < 1)) {
                if (buildMessageBox) buildMessageBox.textContent = "Invalid order number. Please enter a positive integer or leave blank.";
                return;
            }

            let levelDifficulty = 'easy'; // Default difficulty for non-LtpMer users
            let brickReward = 0; // Default brick reward for non-LtpMer users

            if (currentPlayerName === 'LtpMer') {
                const validDifficulties = ['easy', 'medium', 'hard', 'very_hard', 'super_hard'];
                let promptDifficulty = prompt(`Enter difficulty for "${levelName}" (${validDifficulties.join(', ')}):`).toLowerCase();
                if (validDifficulties.includes(promptDifficulty)) {
                    levelDifficulty = promptDifficulty;
                } else {
                    if (buildMessageBox) buildMessageBox.textContent = `Invalid difficulty. Defaulting to 'easy'.`;
                }

                let promptBricks = prompt(`Enter brick reward for "${levelName}" (0-4):`);
                let parsedBricks = parseInt(promptBricks);
                if (!isNaN(parsedBricks) && parsedBricks >= 0 && parsedBricks <= 4) {
                    brickReward = parsedBricks;
                } else {
                    if (buildMessageBox) buildMessageBox.textContent = "Invalid brick reward. Defaulting to 0.";
                }
            }

            try {
                const levelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/levels`);
                const levelData = {
                    name: levelName,
                    grid: JSON.stringify(buildGrid), // Convert grid to string for storage
                    playerStart: player,
                    winpadEnd: end,
                    order: levelOrder, // Store the optional order number
                    createdAt: new Date(),
                    creatorName: currentPlayerName, // Save creator's simulated name
                    difficulty: levelDifficulty, // Store difficulty for saved levels
                    brickReward: brickReward // Store brick reward for saved levels
                };

                if (editingLevelId) {
                    // Update existing level
                    await setDoc(doc(levelsCollectionRef, editingLevelId), levelData, { merge: true });
                    if (buildMessageBox) buildMessageBox.textContent = `Level "${levelName}" updated successfully!`;
                    editingLevelId = null; // Clear editing state
                } else {
                    // Add new level
                    await addDoc(levelsCollectionRef, levelData);
                    if (buildMessageBox) buildMessageBox.textContent = `Level "${levelName}" saved successfully!`;
                }
                loadMyLevels(); // Refresh the list of levels
            } catch (e) {
                console.error("Error saving/updating document: ", e);
                if (buildMessageBox) buildMessageBox.textContent = `Error saving/updating level: ${e.message}. See console for details.`;
            }
        }

        async function publishLevel() {
            if (!window.userId || !window.db) {
                if (buildMessageBox) buildMessageBox.textContent = "Error: Firebase not fully initialized or user not authenticated to publish level.";
                return;
            }
            if (player.x === -1 || end.x === -1) {
                if (buildMessageBox) buildMessageBox.textContent = "Please place both Player Start and Win Pad before publishing!";
                return;
            }

            const levelName = prompt("Enter a name for your public level (max 30 characters):");
            if (!levelName) {
                if (buildMessageBox) buildMessageBox.textContent = "Level publish cancelled.";
                return;
            }
            if (levelName.length > 30) {
                if (buildMessageBox) buildMessageBox.textContent = "Level name exceeds 30 characters. Please shorten it.";
                return;
            }

            let levelDifficulty = 'easy'; // Default difficulty for non-LtpMer users
            let brickReward = 0; // Default brick reward for non-LtpMer users

            if (currentPlayerName === 'LtpMer') {
                const validDifficulties = ['easy', 'medium', 'hard', 'very_hard', 'super_hard'];
                let promptDifficulty = prompt(`Enter difficulty for "${levelName}" (${validDifficulties.join(', ')}):`).toLowerCase();
                if (validDifficulties.includes(promptDifficulty)) {
                    levelDifficulty = promptDifficulty;
                } else {
                    if (buildMessageBox) buildMessageBox.textContent = `Invalid difficulty. Defaulting to 'easy'.`;
                }

                let promptBricks = prompt(`Enter brick reward for "${levelName}" (0-4):`);
                let parsedBricks = parseInt(promptBricks);
                if (!isNaN(parsedBricks) && parsedBricks >= 0 && parsedBricks <= 4) {
                    brickReward = parsedBricks;
                } else {
                    if (buildMessageBox) buildMessageBox.textContent = "Invalid brick reward. Defaulting to 0.";
                }
            }

            try {
                const publicLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/levels`);
                await addDoc(publicLevelsCollectionRef, {
                    name: levelName,
                    grid: JSON.stringify(buildGrid),
                    playerStart: player,
                    winpadEnd: end,
                    createdAt: new Date(),
                    creatorName: currentPlayerName,
                    creatorId: window.userId,
                    isDailyLevel: false, // Default to not a daily level
                    dailyLevelTargetDate: null, // NEW: Field for daily level target date
                    difficulty: levelDifficulty, // Store difficulty for public levels
                    brickReward: brickReward // Store brick reward for public levels
                });
                if (buildMessageBox) buildMessageBox.textContent = `Level "${levelName}" published successfully!`;
            } catch (e) {
                console.error("Error publishing document: ", e);
                if (buildMessageBox) buildMessageBox.textContent = `Error publishing level: ${e.message}. See console for details.`;
            }
        }

        async function loadMyLevels() {
            if (!window.userId || !window.db) {
                if (myLevelsList) myLevelsList.innerHTML = "<div>Please log in to see your levels.</div>";
                console.warn("Cannot load my levels: Firebase not fully initialized or user not authenticated.");
                return;
            }

            if (myLevelsList) myLevelsList.innerHTML = "<div>Loading levels...</div>";
            try {
                const levelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/levels`);
                const q = query(levelsCollectionRef); // No orderBy here to avoid index issues, sort in memory
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    if (myLevelsList) myLevelsList.innerHTML = "<div>No levels saved yet.</div>";
                    return;
                }

                const myLevels = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    myLevels.push({ id: doc.id, ...data });
                });

                // Sort levels: first by existing 'order' (ascending), then by 'createdAt' (oldest first)
                myLevels.sort((a, b) => {
                    if (a.order !== null && b.order !== null) {
                        return a.order - b.order;
                    }
                    if (a.order !== null) return -1; // Levels with order come first
                    if (b.order !== null) return 1;
                    return a.createdAt.toDate() - b.createdAt.toDate(); // Fallback to creation date
                });

                if (myLevelsList) myLevelsList.innerHTML = ''; // Clear previous list
                myLevels.forEach((data) => {
                    const levelDiv = document.createElement('div');
                    const orderDisplay = data.order !== null ? `#${data.order} ` : '';
                    const difficultyDisplay = data.difficulty ? `<span class="level-difficulty">(${data.difficulty.replace('_', ' ')})</span>` : '';
                    const bricksDisplay = (data.brickReward !== undefined && data.brickReward !== null) ? `<span class="level-bricks">🧱 ${data.brickReward}</span>` : '';
                    const creatorDisplay = data.creatorName ? `<span class="level-creator">By ${data.creatorName}</span>` : '';

                    levelDiv.innerHTML = `
                        <div class="level-name-row">
                            <span class="level-name">${orderDisplay}${data.name}</span>
                            <div class="level-metadata">
                                ${difficultyDisplay}
                                ${bricksDisplay}
                            </div>
                        </div>
                        <div class="level-buttons-row">
                            <button class="play-level-button" data-level-id="${data.id}" data-level-name="${data.name}" data-level-grid='${data.grid}' data-player-start='${JSON.stringify(data.playerStart)}' data-winpad-end='${JSON.stringify(data.winpadEnd)}' data-level-difficulty="${data.difficulty || ''}" data-level-brick-reward="${data.brickReward || 0}">Play</button>
                            <button class="edit-level-button" data-level-id="${data.id}" data-level-name="${data.name}" data-level-grid='${data.grid}' data-player-start='${JSON.stringify(data.playerStart)}' data-winpad-end='${JSON.stringify(data.winpadEnd)}'>Edit</button>
                            <button class="delete-level-button" data-level-id="${data.id}">Delete</button>
                            ${currentPlayerName === 'LtpMer' ? `<button class="set-official-button" data-level-id="${data.id}" data-level-name="${data.name}" data-level-grid='${data.grid}' data-player-start='${JSON.stringify(data.playerStart)}' data-winpad-end='${JSON.stringify(data.winpadEnd)}' data-creator-name="${data.creatorName}" data-creator-id="${data.creatorId}" data-level-difficulty="${data.difficulty || ''}" data-level-brick-reward="${data.brickReward || 0}">Set as Official</button>` : ''}
                        </div>
                        ${creatorDisplay}
                    `;
                    if (myLevelsList) myLevelsList.appendChild(levelDiv);
                });

                // Add event listeners to the dynamically created buttons
                if (myLevelsList) {
                    myLevelsList.querySelectorAll('.play-level-button').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const levelData = {
                                id: e.target.dataset.levelId,
                                name: e.target.dataset.levelName,
                                grid: JSON.parse(e.target.dataset.levelGrid),
                                playerStart: JSON.parse(e.target.dataset.playerStart),
                                winpadEnd: JSON.parse(e.target.dataset.winpadEnd),
                                difficulty: e.target.dataset.levelDifficulty, // Pass difficulty
                                brickReward: parseInt(e.target.dataset.levelBrickReward) // Pass brick reward
                            };
                            playSavedLevel(levelData);
                        });
                    });

                    // New: Add event listener for "Edit" button
                    myLevelsList.querySelectorAll('.edit-level-button').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const levelData = {
                                id: e.target.dataset.levelId,
                                name: e.target.dataset.levelName,
                                grid: JSON.parse(e.target.dataset.levelGrid),
                                playerStart: JSON.parse(e.target.dataset.playerStart),
                                winpadEnd: JSON.parse(e.target.dataset.winpadEnd)
                            };
                            editLevel(levelData);
                        });
                    });

                    myLevelsList.querySelectorAll('.delete-level-button').forEach(button => {
                        button.addEventListener('click', async (e) => {
                            const levelId = e.target.dataset.levelId;
                            // Replaced confirm with a custom message box or modal if available
                            if (window.confirm("Are you sure you want to delete this level?")) {
                                try {
                                    // Admin override: LtpMer can delete any level, otherwise only own levels
                                    if (currentPlayerName === 'LtpMer') {
                                        // Try to delete from public levels first if it exists there
                                        const publicLevelRef = doc(window.db, `artifacts/${window.__app_id}/public/data/levels`, levelId);
                                        const publicDocSnap = await getDoc(publicLevelRef);
                                        if (publicDocSnap.exists()) {
                                            await deleteDoc(publicLevelRef);
                                            console.log(`Admin (LtpMer) deleted public level: ${levelId}`);
                                        }
                                        // Also try to delete from official levels if it exists there
                                        // Note: Official levels are named 'level-ORDER_NUMBER', not by their original ID.
                                        // We need to find the official level by its content ID
                                        const officialLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/official_levels`);
                                        const qOfficial = query(officialLevelsCollectionRef, where("id", "==", levelId));
                                        const officialSnapshot = await getDocs(qOfficial);
                                        officialSnapshot.forEach(async (officialDoc) => {
                                            await deleteDoc(doc(officialLevelsCollectionRef, officialDoc.id));
                                            console.log(`Admin (LtpMer) deleted official level document: ${officialDoc.id}`);
                                        });
                                        fetchOfficialPlayableLevels(); // Refresh official levels after deletion (no difficulty param anymore)
                                    }
                                    // Always delete from user's private levels
                                    await deleteDoc(doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/levels`, levelId));
                                    if (messageBox) messageBox.textContent = "Level deleted successfully!";
                                    setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000); // Clear message after 3 seconds
                                    loadMyLevels(); // Refresh the list
                                } catch (error) {
                                    console.error("Error deleting level:", error);
                                    if (messageBox) messageBox.textContent = `Error deleting level: ${error.message}. See console.`;
                                    setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000); // Clear message after 3 seconds
                                }
                            }
                        });
                    });

                    // New: Add event listener for "Set as Official" button
                    myLevelsList.querySelectorAll('.set-official-button').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const levelData = {
                                id: e.target.dataset.levelId,
                                name: e.target.dataset.levelName,
                                grid: e.target.dataset.levelGrid, // Keep as string for direct storage
                                playerStart: JSON.parse(e.target.dataset.playerStart),
                                winpadEnd: JSON.parse(e.target.dataset.winpadEnd),
                                creatorName: e.target.dataset.creatorName,
                                creatorId: e.target.dataset.creatorId,
                                difficulty: e.target.dataset.levelDifficulty, // Pass difficulty
                                brickReward: parseInt(e.target.dataset.levelBrickReward) // Pass brick reward
                            };
                            setOfficialLevel(levelData);
                        });
                    });
                }

            } catch (e) {
                console.error("Error loading documents: ", e);
                if (myLevelsList) myLevelsList.innerHTML = `<div>Error loading levels: ${e.message}.</div>`;
            }
        }

        // Modified loadCommunityLevels to accept a search query
        async function loadCommunityLevels(searchQuery = '') {
            const targetListElement = communityLevelsModalOverlay && communityLevelsModalOverlay.classList.contains('show') ? communityLevelsListModal : communityLevelsListInMenu;
            // The input for the menu modal is levelSearchInput, for the separate modal it's communityLevelSearchInputModal
            // This variable is not directly used here, but for clarity in the event listener setup.

            if (!targetListElement) return; // Exit if the target list element is not found

            if (!window.userId || !window.db) {
                targetListElement.innerHTML = "<div>Please log in to see community levels.</div>";
                console.warn("Cannot load community levels: Firebase not fully initialized or user not authenticated.");
                return;
            }

            targetListElement.innerHTML = "<div>Loading community levels...</div>";
            try {
                const publicLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/levels`);
                // Fetch all levels and filter client-side for name search
                const querySnapshot = await getDocs(publicLevelsCollectionRef);

                let filteredLevels = [];
                const lowerCaseSearchQuery = searchQuery.toLowerCase().trim();

                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const levelName = data.name ? data.name.toLowerCase() : '';
                    const levelId = doc.id;

                    // Filter logic: if search query is empty, include all. Otherwise, check name or ID.
                    if (lowerCaseSearchQuery === '' || levelName.includes(lowerCaseSearchQuery) || levelId === lowerCaseSearchQuery) {
                        filteredLevels.push({ id: levelId, ...data });
                    }
                });

                if (filteredLevels.length === 0) {
                    targetListElement.innerHTML = "<div>No community levels found matching your search.</div>";
                    return;
                }

                targetListElement.innerHTML = ''; // Clear previous list
                filteredLevels.forEach((data) => {
                    const levelId = data.id;
                    // Define isLtpMer and isCreator inside this loop
                    const isLtpMer = currentPlayerName === 'LtpMer';
                    const isCreator = data.creatorId === window.userId;

                    const difficultyDisplay = data.difficulty ? `<span class="level-difficulty">(${data.difficulty.replace('_', ' ')})</span>` : '';
                    const bricksDisplay = (data.brickReward !== undefined && data.brickReward !== null) ? `<span class="level-bricks">🧱 ${data.brickReward}</span>` : '';
                    const creatorDisplay = data.creatorName ? `<span class="level-creator">By ${data.creatorName}</span>` : '';

                    let adminActionsHtml = '';
                    if (isLtpMer || isCreator) { // This is the line where the error was occurring
                        adminActionsHtml += `
                            <div class="community-level-actions">
                                ${isLtpMer ? `
                                    <select class="set-difficulty-select" data-level-id="${levelId}">
                                        <option value="">Set Diff</option>
                                        <option value="easy">Easy</option>
                                        <option value="medium">Medium</option>
                                        <option value="hard">Hard</option>
                                        <option value="very_hard">Very Hard</option>
                                        <option value="super_hard">Super Hard</option>
                                    </select>
                                    <input type="number" class="set-bricks-input" data-level-id="${levelId}" placeholder="Bricks" min="0" max="4" value="${data.brickReward || 0}">
                                    <button class="update-level-props-button" data-level-id="${levelId}">Update Props</button>
                                    <button class="set-daily-button-community" data-level-id="${levelId}">Set Daily</button>
                                ` : ''}
                                ${isCreator ? `<button class="delete-level-button" data-level-id="${levelId}">Delete</button>` : ''}
                            </div>
                        `;
                    }

                    const levelDiv = document.createElement('div');
                    levelDiv.innerHTML = `
                        <div class="level-name-row">
                            <span class="level-name">${data.name}</span>
                            <div class="level-metadata">
                                ${difficultyDisplay}
                                ${bricksDisplay}
                            </div>
                        </div>
                        <div class="level-buttons-row">
                            <button class="play-level-button" data-level-id="${levelId}" data-level-name="${data.name}" data-level-grid='${data.grid}' data-player-start='${JSON.stringify(data.playerStart)}' data-winpad-end='${JSON.stringify(data.winpadEnd)}' data-level-difficulty="${data.difficulty || ''}" data-level-brick-reward="${data.brickReward || 0}">Play</button>
                        </div>
                        ${creatorDisplay}
                        ${adminActionsHtml}
                    `;
                    targetListElement.appendChild(levelDiv);
                });

                // Add event listeners for play buttons
                targetListElement.querySelectorAll('.play-level-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const levelData = {
                            id: e.target.dataset.levelId,
                            name: e.target.dataset.levelName,
                            grid: JSON.parse(e.target.dataset.levelGrid),
                            playerStart: JSON.parse(e.target.dataset.playerStart),
                            winpadEnd: JSON.parse(e.target.dataset.winpadEnd),
                            difficulty: e.target.dataset.levelDifficulty,
                            brickReward: parseInt(e.target.dataset.levelBrickReward)
                        };
                        playCommunityLevel(levelData);
                    });
                });

                // Add event listeners for admin actions (if applicable)
                if (true) { // This block needs to run to attach listeners, even if isLtpMer/isCreator are false
                    targetListElement.querySelectorAll('.update-level-props-button').forEach(button => {
                        button.addEventListener('click', async (e) => {
                            const levelId = e.target.dataset.levelId;
                            const parentDiv = e.target.closest('.community-level-actions');
                            const difficultySelect = parentDiv.querySelector('.set-difficulty-select');
                            const bricksInput = parentDiv.querySelector('.set-bricks-input');

                            const newDifficulty = difficultySelect.value;
                            const newBricks = parseInt(bricksInput.value);

                            if (!newDifficulty || isNaN(newBricks) || newBricks < 0 || newBricks > 4) {
                                if (messageBox) messageBox.textContent = "Invalid difficulty or bricks value.";
                                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                                return;
                            }

                            try {
                                const levelRef = doc(window.db, `artifacts/${window.__app_id}/public/data/levels`, levelId);
                                await updateDoc(levelRef, {
                                    difficulty: newDifficulty,
                                    brickReward: newBricks
                                });
                                if (messageBox) messageBox.textContent = `Level ${levelId} properties updated!`;
                                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                                loadCommunityLevels(searchQuery); // Refresh list to show changes
                            } catch (error) {
                                console.error("Error updating level properties:", error);
                                if (messageBox) messageBox.textContent = `Error updating properties: ${error.message}.`;
                                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                            }
                        });
                    });

                    targetListElement.querySelectorAll('.set-daily-button-community').forEach(button => {
                        button.addEventListener('click', async (e) => {
                            const levelId = e.target.dataset.levelId;
                            // Set this level as the daily level
                            await setDailyLevel(levelId);
                            loadCommunityLevels(searchQuery); // Refresh list to show changes
                        });
                    });

                    targetListElement.querySelectorAll('.delete-level-button').forEach(button => {
                        button.addEventListener('click', async (e) => {
                            const levelId = e.target.dataset.levelId;
                            if (window.confirm("Are you sure you want to delete this community level?")) {
                                try {
                                    await deleteDoc(doc(window.db, `artifacts/${window.__app_id}/public/data/levels`, levelId));
                                    if (messageBox) messageBox.textContent = "Community level deleted successfully!";
                                    setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                                    loadCommunityLevels(searchQuery); // Refresh the list
                                } catch (error) {
                                    console.error("Error deleting community level:", error);
                                    if (messageBox) messageBox.textContent = `Error deleting level: ${error.message}.`;
                                    setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                                }
                            }
                        });
                    });
                }

            } catch (e) {
                console.error("Error loading community levels:", e);
                targetListElement.innerHTML = `<div>Error loading community levels: ${e.message}.</div>`;
            }
        }

        async function playSavedLevel(levelData) {
            mazeGrid = levelData.grid;
            player = levelData.playerStart;
            end = levelData.winpadEnd;
            currentLevelId = levelData.id;
            currentLevelName = levelData.name;
            currentLevelDifficulty = levelData.difficulty || 'N/A';
            currentLevelBrickReward = levelData.brickReward || 0;
            currentGameType = GAME_MODES.SAVED_LEVEL;
            hideAllModals();
            showScreen('gamePlayArea');
        }

        async function playCommunityLevel(levelData) {
            mazeGrid = levelData.grid;
            player = levelData.playerStart;
            end = levelData.winpadEnd;
            currentLevelId = levelData.id;
            currentLevelName = levelData.name;
            currentLevelDifficulty = levelData.difficulty || 'N/A';
            currentLevelBrickReward = levelData.brickReward || 0;
            currentGameType = GAME_MODES.COMMUNITY_LEVEL;
            hideAllModals();
            showScreen('gamePlayArea');
        }

        async function editLevel(levelData) {
            buildGrid = levelData.grid;
            player = levelData.playerStart;
            end = levelData.winpadEnd;
            editingLevelId = levelData.id; // Set the ID of the level being edited
            hideAllModals();
            currentGameType = GAME_MODES.BUILD;
            showScreen('buildModeArea');
            if (buildMessageBox) buildMessageBox.textContent = `Editing level: "${levelData.name}"`;
            drawBuild(); // Ensure build canvas is drawn with the loaded level
        }

        // Admin function to set a level as official
        async function setOfficialLevel(levelData) {
            if (currentPlayerName !== 'LtpMer') {
                if (messageBox) messageBox.textContent = "Only LtpMer can set official levels.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                return;
            }

            let orderNum = prompt(`Enter an order number for this official level (e.g., 1, 2, 3...). This will be its new ID in the official list.`);
            if (!orderNum) {
                if (messageBox) messageBox.textContent = "Operation cancelled.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                return;
            }
            orderNum = parseInt(orderNum);
            if (isNaN(orderNum) || orderNum < 1) {
                if (messageBox) messageBox.textContent = "Invalid order number. Must be a positive integer.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                return;
            }

            try {
                const officialLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/official_levels`);
                const officialDocRef = doc(officialLevelsCollectionRef, `level-${orderNum}`); // Use order number as doc ID

                await setDoc(officialDocRef, {
                    id: levelData.id, // Keep original ID for reference
                    name: levelData.name,
                    grid: levelData.grid, // Grid is already stringified
                    playerStart: levelData.playerStart,
                    winpadEnd: levelData.winpadEnd,
                    order: orderNum,
                    createdAt: new Date(),
                    creatorName: levelData.creatorName,
                    creatorId: levelData.creatorId,
                    difficulty: levelData.difficulty,
                    brickReward: levelData.brickReward
                });
                if (messageBox) messageBox.textContent = `Level "${levelData.name}" set as official level ${orderNum}!`;
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                fetchOfficialPlayableLevels(); // Refresh the official levels list
            } catch (e) {
                console.error("Error setting official level:", e);
                if (messageBox) messageBox.textContent = `Error setting official level: ${e.message}.`;
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
            }
        }

        // Fetch official levels for the "Play" button
        async function fetchOfficialPlayableLevels() {
            if (!window.db) {
                console.warn("Cannot fetch official levels: Firebase not initialized.");
                return;
            }
            try {
                const officialLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/official_levels`);
                const q = query(officialLevelsCollectionRef, orderBy("order", "asc")); // Order by the 'order' field
                const querySnapshot = await getDocs(q);
                officialPlayableLevels = [];
                querySnapshot.forEach((doc) => {
                    officialPlayableLevels.push({ id: doc.id, ...doc.data() });
                });
                console.log("Official playable levels loaded:", officialPlayableLevels);
                // Reset currentLevelIndex if needed, e.g., if levels change
                currentLevelIndex = 0;
            } catch (e) {
                console.error("Error fetching official playable levels:", e);
            }
        }

        // Fetch the daily level
        async function fetchDailyLevel() {
            if (!window.db) {
                console.warn("Cannot fetch daily level: Firebase not initialized.");
                return;
            }
            try {
                const dailyLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/daily_level`);
                // Get the single daily level document (assuming there's only one or we pick the first)
                const querySnapshot = await getDocs(query(dailyLevelsCollectionRef, limit(1)));

                if (!querySnapshot.empty) {
                    const dailyLevelDoc = querySnapshot.docs[0];
                    currentDailyLevel = { id: dailyLevelDoc.id, ...dailyLevelDoc.data() };
                    if (dailyLevelName) dailyLevelName.textContent = `Level: ${currentDailyLevel.name}`;
                    if (dailyLevelContainer) dailyLevelContainer.style.display = 'block';
                    console.log("Daily level loaded:", currentDailyLevel);
                } else {
                    if (dailyLevelName) dailyLevelName.textContent = "No daily level set.";
                    if (dailyLevelContainer) dailyLevelContainer.style.display = 'none';
                    currentDailyLevel = null;
                }
            } catch (e) {
                console.error("Error fetching daily level:", e);
                if (dailyLevelName) dailyLevelName.textContent = "Error loading daily level.";
                if (dailyLevelContainer) dailyLevelContainer.style.display = 'none';
                currentDailyLevel = null;
            }
        }

        // Admin function to set a level as the daily level
        async function setDailyLevel(levelId) {
            if (currentPlayerName !== 'LtpMer') {
                if (messageBox) messageBox.textContent = "Only LtpMer can set daily levels.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                return;
            }

            if (!window.db) {
                if (messageBox) messageBox.textContent = "Error: Firebase not initialized.";
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                return;
            }

            try {
                // First, get the level data from public levels
                const levelRef = doc(window.db, `artifacts/${window.__app_id}/public/data/levels`, levelId);
                const levelSnap = await getDoc(levelRef);

                if (!levelSnap.exists()) {
                    if (messageBox) messageBox.textContent = "Level not found in community levels.";
                    setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                    return;
                }

                const levelData = levelSnap.data();

                // Delete existing daily level (if any)
                const dailyLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/daily_level`);
                const existingDailyLevels = await getDocs(dailyLevelsCollectionRef);
                existingDailyLevels.forEach(async (doc) => {
                    await deleteDoc(doc.ref);
                });

                // Add the new daily level
                await addDoc(dailyLevelsCollectionRef, {
                    id: levelId, // Store the original level ID
                    name: levelData.name,
                    grid: levelData.grid,
                    playerStart: levelData.playerStart,
                    winpadEnd: levelData.winpadEnd,
                    creatorName: levelData.creatorName,
                    creatorId: levelData.creatorId,
                    difficulty: levelData.difficulty,
                    brickReward: levelData.brickReward,
                    setAt: new Date() // Timestamp when it was set
                });

                if (messageBox) messageBox.textContent = `Level "${levelData.name}" set as the daily level!`;
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                fetchDailyLevel(); // Refresh the daily level display
            } catch (e) {
                console.error("Error setting daily level:", e);
                if (messageBox) messageBox.textContent = `Error setting daily level: ${e.message}.`;
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
            }
        }

        // Load leaderboard data
        async function loadLeaderboard() {
            if (!window.db) {
                if (leaderboardList) leaderboardList.innerHTML = "<div>Leaderboard not available.</div>";
                console.warn("Cannot load leaderboard: Firebase not initialized.");
                return;
            }

            if (leaderboardList) leaderboardList.innerHTML = "<div>Loading leaderboard...</div>";
            try {
                // Leaderboard now shows top players by bricks
                const leaderboardCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/user_bricks_scores`);
                const q = query(leaderboardCollectionRef, orderBy("bricks", "desc"), limit(10)); // Top 10 by bricks
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    if (leaderboardList) leaderboardList.innerHTML = "<div>No scores yet. Play some levels!</div>";
                    return;
                }

                if (leaderboardList) leaderboardList.innerHTML = ''; // Clear previous list
                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const entryDiv = document.createElement('div');
                    entryDiv.classList.add('leaderboard-entry');
                    entryDiv.innerHTML = `
                        <span class="rank">${rank}.</span>
                        <span class="player-name">${data.playerName || 'Anonymous'}</span>
                        <span class="bricks">🧱 ${data.bricks}</span>
                    `;
                    if (leaderboardList) leaderboardList.appendChild(entryDiv);
                    rank++;
                });
            } catch (e) {
                console.error("Error loading leaderboard:", e);
                if (leaderboardList) leaderboardList.innerHTML = `<div>Error loading leaderboard: ${e.message}.</div>`;
            }
        }

        // --- Custom Block Definition Functions ---
        async function saveCustomBlockDefinition() {
            if (!window.userId || !window.db) {
                if (messageBox) messageBox.textContent = "Error: Firebase not initialized or user not authenticated.";
                return;
            }

            const blockId = customBlockNameInput.value.trim();
            const blockColor = customBlockColorPicker.value;
            const blockScriptRaw = customBlockScriptInput.value.trim();

            if (!blockId) {
                if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = "Block ID cannot be empty.";
                return;
            }
            if (blockId.length > 50) {
                if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = "Block ID max 50 characters.";
                return;
            }
            if (!/^[a-zA-Z0-9_]+$/.test(blockId)) {
                if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = "Block ID can only contain letters, numbers, and underscores.";
                return;
            }

            let parsedScript;
            try {
                parsedScript = JSON.parse(blockScriptRaw);
                if (!Array.isArray(parsedScript)) {
                    throw new Error("Script must be a JSON array.");
                }
                // Basic validation for script structure (can be expanded)
                for (const action of parsedScript) {
                    if (typeof action !== 'object' || !action.type || !action.params) {
                        throw new Error("Each action must be an object with 'type' and 'params'.");
                    }
                }
            } catch (e) {
                if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = `Invalid JSON script: ${e.message}`;
                return;
            }

            try {
                const definitionsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/custom_block_definitions`);
                const docRef = doc(definitionsCollectionRef, blockId); // Use blockId as document ID

                await setDoc(docRef, {
                    color: blockColor,
                    script: parsedScript,
                    createdAt: new Date(),
                    lastUpdated: new Date()
                }, { merge: true }); // Use merge to update if exists

                if (messageBox) messageBox.textContent = `Custom Block '${blockId}' saved successfully!`;
                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                loadCustomBlockDefinitionsFromFirestore(); // Refresh the list
                editingCustomBlockId = null; // Clear editing state
                customBlockNameInput.value = '';
                customBlockColorPicker.value = CUSTOM_BLOCK_DEFAULT_COLOR;
                customBlockScriptInput.value = '';
                deleteCustomBlockDefinitionButton.style.display = 'none'; // Hide delete button
            } catch (e) {
                console.error("Error saving custom block definition:", e);
                if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = `Error saving definition: ${e.message}`;
            }
        }

        async function loadCustomBlockDefinitionsFromFirestore() {
            if (!window.userId || !window.db) {
                if (customBlockDefinitionsList) customBlockDefinitionsList.innerHTML = "<div>Please log in to see your custom block definitions.</div>";
                console.warn("Cannot load custom block definitions: Firebase not initialized or user not authenticated.");
                return;
            }

            customBlockDefinitions = {}; // Clear existing definitions
            if (customBlockDefinitionsList) customBlockDefinitionsList.innerHTML = "<div>Loading definitions...</div>";

            try {
                const definitionsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/custom_block_definitions`);
                const querySnapshot = await getDocs(definitionsCollectionRef);

                if (querySnapshot.empty) {
                    if (customBlockDefinitionsList) customBlockDefinitionsList.innerHTML = "<div>No custom block definitions saved yet.</div>";
                    return;
                }

                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    customBlockDefinitions[doc.id] = {
                        color: data.color,
                        script: data.script
                    };
                });
                renderCustomBlockDefinitionsList();
            } catch (e) {
                console.error("Error loading custom block definitions:", e);
                if (customBlockDefinitionsList) customBlockDefinitionsList.innerHTML = `<div>Error loading definitions: ${e.message}.</div>`;
            }
        }

        function renderCustomBlockDefinitionsList() {
            if (customBlockDefinitionsList) customBlockDefinitionsList.innerHTML = ''; // Clear previous list
            const definitionIds = Object.keys(customBlockDefinitions);

            if (definitionIds.length === 0) {
                if (customBlockDefinitionsList) customBlockDefinitionsList.innerHTML = "<div>No custom block definitions saved yet.</div>";
                return;
            }

            definitionIds.forEach(id => {
                const definition = customBlockDefinitions[id];
                const itemDiv = document.createElement('div');
                itemDiv.innerHTML = `
                    <span style="color: ${definition.color}; font-weight: bold;">${id}</span>
                    <div>
                        <button class="select-custom-block-button" data-id="${id}">Select</button>
                        <button class="edit-custom-block-button" data-id="${id}">Edit</button>
                        <button class="delete-custom-block-button" data-id="${id}">Delete</button>
                    </div>
                `;
                if (customBlockDefinitionsList) customBlockDefinitionsList.appendChild(itemDiv);
            });

            // Add event listeners to dynamically created buttons
            if (customBlockDefinitionsList) {
                customBlockDefinitionsList.querySelectorAll('.select-custom-block-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        currentSelectedCustomBlockId = e.target.dataset.id;
                        if (buildMessageBox) buildMessageBox.textContent = `Custom Block Tool: '${currentSelectedCustomBlockId}' selected.`;
                        hideModal(customBlockEditorModalOverlay);
                        selectBuildTool(BLOCK_TYPES.CUSTOM_BLOCK); // Ensure custom block tool is active
                    });
                });

                customBlockDefinitionsList.querySelectorAll('.edit-custom-block-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const idToEdit = e.target.dataset.id;
                        const definition = customBlockDefinitions[idToEdit];
                        if (definition) {
                            customBlockNameInput.value = idToEdit;
                            customBlockColorPicker.value = definition.color;
                            customBlockScriptInput.value = JSON.stringify(definition.script, null, 2); // Pretty print JSON
                            editingCustomBlockId = idToEdit; // Set editing state
                            deleteCustomBlockDefinitionButton.style.display = 'block'; // Show delete button when editing
                            if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = `Editing: ${idToEdit}`;
                        }
                    });
                });

                customBlockDefinitionsList.querySelectorAll('.delete-custom-block-button').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const idToDelete = e.target.dataset.id;
                        if (window.confirm(`Are you sure you want to delete custom block definition '${idToDelete}'?`)) {
                            try {
                                await deleteDoc(doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/custom_block_definitions`, idToDelete));
                                if (messageBox) messageBox.textContent = `Custom Block '${idToDelete}' deleted.`;
                                setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                                loadCustomBlockDefinitionsFromFirestore(); // Refresh the list
                                // If the deleted block was currently selected, clear selection
                                if (currentSelectedCustomBlockId === idToDelete) {
                                    currentSelectedCustomBlockId = null;
                                    if (buildMessageBox) buildMessageBox.textContent = "Custom Block selection cleared.";
                                }
                                // If the deleted block was being edited, clear editor fields
                                if (editingCustomBlockId === idToDelete) {
                                    customBlockNameInput.value = '';
                                    customBlockColorPicker.value = CUSTOM_BLOCK_DEFAULT_COLOR;
                                    customBlockScriptInput.value = '';
                                    editingCustomBlockId = null;
                                    deleteCustomBlockDefinitionButton.style.display = 'none';
                                }
                            } catch (error) {
                                console.error("Error deleting custom block definition:", error);
                                if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = `Error deleting definition: ${error.message}`;
                            }
                        }
                    });
                });
            }
        }

        function showCustomBlockEditorModal() {
            hideAllModals(); // Hide other modals
            showModal(customBlockEditorModalOverlay);
            loadCustomBlockDefinitionsFromFirestore(); // Load definitions when opening
            // Reset form fields if not editing
            if (!editingCustomBlockId) {
                customBlockNameInput.value = '';
                customBlockColorPicker.value = CUSTOM_BLOCK_DEFAULT_COLOR;
                customBlockScriptInput.value = '';
                deleteCustomBlockDefinitionButton.style.display = 'none';
            }
            if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = "Define or select a custom block behavior.";
        }

        // --- Event Listeners and Initialization ---
        window.onload = () => {
            // Get references to HTML elements
            startScreen = document.getElementById('startScreen');
            gamePlayArea = document.getElementById('gamePlayArea');
            buildModeArea = document.getElementById('buildModeArea');

            infoButton = document.getElementById('infoButton');
            loginButton = document.getElementById('loginButton');
            guidesButton = document.getElementById('guidesButton'); // Get guides button

            playButton = document.getElementById('playButton');
            customizationButtonStart = document.getElementById('customizationButtonStart');
            menuButtonStart = document.getElementById('menuButtonStart');
            leaderboardButton = document.getElementById('leaderboardButton'); // Get leaderboard button
            dailyLevelContainer = document.getElementById('dailyLevelContainer');
            dailyLevelName = document.getElementById('dailyLevelName');
            playDailyLevelButton = document.getElementById('playDailyLevelButton');

            mazeCanvas = document.getElementById('mazeCanvas');
            mazeCtx = mazeCanvas ? mazeCanvas.getContext('2d') : null;
            messageBox = document.getElementById('messageBox');
            playerHealthDisplay = document.getElementById('playerHealthDisplay'); // Get health display
            nextLevelButton = document.getElementById('nextLevelButton');
            editCurrentLevelButton = document.getElementById('editCurrentLevelButton');
            backToMainMenuButtonGame = document.getElementById('backToMainMenuButtonGame');
            touchControls = document.querySelector('.touch-controls');


            buildCanvas = document.getElementById('buildCanvas');
            buildCtx = buildCanvas ? buildCanvas.getContext('2d') : null;
            buildMessageBox = document.getElementById('buildMessageBox');
            clearBuildGridButton = document.getElementById('clearBuildGridButton');
            saveLevelButton = document.getElementById('saveLevelButton');
            publishLevelButton = document.getElementById('publishLevelButton');
            backToMainMenuButtonBuild = document.getElementById('backToMainMenuButtonBuild');

            infoModalOverlay = document.getElementById('infoModalOverlay');
            closeInfoModalButton = document.getElementById('closeInfoModalButton');
            // Removed guidesModalOverlay and closeGuidesModalButton as they are no longer needed
            customizationModalOverlay = document.getElementById('customizationModalOverlay');
            closeCustomizationModalButton = document.getElementById('closeCustomizationModalButton');
            menuModalOverlay = document.getElementById('menuModalOverlay');
            closeMenuModalButton = document.getElementById('closeMenuModalButton');
            loginModalOverlay = document.getElementById('loginModalOverlay');
            playerNameInput = document.getElementById('playerNameInput');
            passwordInput = document.getElementById('passwordInput');
            loginSubmitButton = document.getElementById('loginSubmitButton');
            loginCancelButton = document.getElementById('loginCancelButton');
            communityLevelsModalOverlay = document.getElementById('communityLevelsModalOverlay');
            communityLevelSearchInputModal = document.getElementById('communityLevelSearchInputModal');
            searchCommunityLevelsButtonModal = document.getElementById('searchCommunityLevelsButtonModal');
            communityLevelsListModal = document.getElementById('communityLevelsListModal');
            refreshCommunityLevelsButtonModal = document.getElementById('refreshCommunityLevelsButtonModal');
            closeCommunityLevelsModalButton = document.getElementById('closeCommunityLevelsModalButton');
            leaderboardList = document.getElementById('leaderboardList');
            refreshLeaderboardButton = document.getElementById('refreshLeaderboardButton');
            closeLeaderboardModalButton = document.getElementById('closeLeaderboardModalButton');

            startRandomMazeButton = document.getElementById('startRandomMazeButton');
            startRandomBlocksButton = document.getElementById('startRandomBlocksButton');
            buildModeButton = document.getElementById('buildModeButton');
            userIdDisplay = document.getElementById('userIdDisplay');
            playerBricksDisplay = document.getElementById('playerBricksDisplay');
            myLevelsList = document.getElementById('myLevelsList');
            refreshMyLevelsButton = document.getElementById('refreshMyLevelsButton');
            communityLevelsButtonMenu = document.getElementById('communityLevelsButtonMenu'); // New button

            playerColorPicker = document.getElementById('playerColorPicker');
            wallColorPicker = document.getElementById('wallColorPicker');
            pathColorPicker = document.getElementById('pathColorPicker');

            drawingToolsContainer = document.getElementById('drawingTools');
            selectionActionsContainer = document.getElementById('selectionActions');

            toolEraser = document.getElementById('toolEraser');
            toolWall = document.getElementById('toolWall');
            toolPath = document.getElementById('toolPath');
            toolPlayer = document.getElementById('toolPlayer');
            toolWinpad = document.getElementById('toolWinpad');
            toolDamagingBlock = document.getElementById('toolDamagingBlock');
            toolPushBlock = document.getElementById('toolPushBlock');
            toolCustomBlock = document.getElementById('toolCustomBlock');
            toolSelection = document.getElementById('toolSelection');

            fillSelectionButton = document.getElementById('fillSelectionButton');
            clearSelectionButton = document.getElementById('clearSelectionButton');
            exitSelectionButton = document.getElementById('exitSelectionButton');

            // Custom Block Editor elements
            customBlockEditorModalOverlay = document.getElementById('customBlockEditorModalOverlay');
            customBlockNameInput = document.getElementById('customBlockNameInput');
            customBlockColorPicker = document.getElementById('customBlockColorPicker');
            customBlockScriptInput = document.getElementById('customBlockScriptInput');
            saveCustomBlockDefinitionButton = document.getElementById('saveCustomBlockDefinitionButton');
            deleteCustomBlockDefinitionButton = document.getElementById('deleteCustomBlockDefinitionButton');
            customBlockDefinitionsList = document.getElementById('customBlockDefinitionsList');
            closeCustomBlockEditorButton = document.getElementById('closeCustomBlockEditorButton');


            // Event Listeners
            if (infoButton) infoButton.addEventListener('click', () => showModal(infoModalOverlay));
            if (closeInfoModalButton) closeInfoModalButton.addEventListener('click', () => hideModal(infoModalOverlay));

            // Guides button now opens external URL
            if (guidesButton) guidesButton.addEventListener('click', () => {
                window.open('https://ltpmer.github.io/GuidesforMazeGame', '_blank');
            });
            // Removed event listener for closeGuidesModalButton as the modal is removed.

            if (loginButton) loginButton.addEventListener('click', () => {
                if (loginButton.classList.contains('logged-in')) {
                    handleLogout();
                } else {
                    showModal(loginModalOverlay);
                }
            });
            if (loginSubmitButton) loginSubmitButton.addEventListener('click', handleLogin);
            if (loginCancelButton) loginCancelButton.addEventListener('click', () => hideModal(loginModalOverlay));

            if (playButton) playButton.addEventListener('click', () => {
                currentGameType = GAME_MODES.LEVEL;
                currentLevelIndex = 0; // Start from the first official level
                showScreen('gamePlayArea');
            });
            if (customizationButtonStart) customizationButtonStart.addEventListener('click', () => showModal(customizationModalOverlay));
            if (closeCustomizationModalButton) closeCustomizationModalButton.addEventListener('click', () => {
                hideModal(customizationModalOverlay);
                saveCustomization(); // Save settings when closing customization
            });
            if (menuButtonStart) menuButtonStart.addEventListener('click', () => {
                showModal(menuModalOverlay);
                loadMyLevels(); // Load levels when menu is opened
                fetchPlayerBricks(); // Refresh bricks display
            });
            if (closeMenuModalButton) closeMenuModalButton.addEventListener('click', () => hideModal(menuModalOverlay));
            if (leaderboardButton) leaderboardButton.addEventListener('click', () => {
                showModal(leaderboardModalOverlay);
                loadLeaderboard();
            });
            if (closeLeaderboardModalButton) closeLeaderboardModalButton.addEventListener('click', () => hideModal(leaderboardModalOverlay));


            if (playerColorPicker) playerColorPicker.addEventListener('input', (e) => { PLAYER_COLOR = e.target.value; drawGame(); drawBuild(); });
            if (wallColorPicker) wallColorPicker.addEventListener('input', (e) => { WALL_COLOR = e.target.value; drawGame(); drawBuild(); });
            if (pathColorPicker) pathColorPicker.addEventListener('input', (e) => { PATH_COLOR = e.target.value; drawGame(); drawBuild(); });

            if (startRandomMazeButton) startRandomMazeButton.addEventListener('click', () => {
                currentGameType = GAME_MODES.MAZE;
                hideAllModals();
                showScreen('gamePlayArea');
            });
            if (startRandomBlocksButton) startRandomBlocksButton.addEventListener('click', () => {
                currentGameType = GAME_MODES.BLOCKS;
                hideAllModals();
                showScreen('gamePlayArea');
            });
            if (buildModeButton) buildModeButton.addEventListener('click', () => {
                currentGameType = GAME_MODES.BUILD;
                hideAllModals();
                showScreen('buildModeArea');
            });
            if (communityLevelsButtonMenu) communityLevelsButtonMenu.addEventListener('click', () => { // New button listener
                showModal(communityLevelsModalOverlay);
                loadCommunityLevels(); // Load all community levels initially
            });
            if (closeCommunityLevelsModalButton) closeCommunityLevelsModalButton.addEventListener('click', () => hideModal(communityLevelsModalOverlay));
            if (searchCommunityLevelsButtonModal) searchCommunityLevelsButtonModal.addEventListener('click', () => {
                loadCommunityLevels(communityLevelSearchInputModal.value);
            });
            if (refreshCommunityLevelsButtonModal) refreshCommunityLevelsButtonModal.addEventListener('click', () => {
                loadCommunityLevels(communityLevelSearchInputModal.value);
            });


            if (refreshMyLevelsButton) refreshMyLevelsButton.addEventListener('click', loadMyLevels);
            if (refreshLeaderboardButton) refreshLeaderboardButton.addEventListener('click', loadLeaderboard);

            if (playDailyLevelButton) playDailyLevelButton.addEventListener('click', () => {
                if (currentDailyLevel) {
                    playCommunityLevel({ // Use playCommunityLevel as it handles the data structure correctly
                        id: currentDailyLevel.id,
                        name: currentDailyLevel.name,
                        grid: JSON.parse(currentDailyLevel.grid),
                        playerStart: currentDailyLevel.playerStart,
                        winpadEnd: currentDailyLevel.winpadEnd,
                        difficulty: currentDailyLevel.difficulty,
                        brickReward: currentDailyLevel.brickReward
                    });
                } else {
                    if (messageBox) messageBox.textContent = "No daily level available.";
                }
            });


            // Game Play Area Buttons
            if (nextLevelButton) nextLevelButton.addEventListener('click', () => {
                if (currentGameType === GAME_MODES.LEVEL) {
                    currentLevelIndex++;
                    if (currentLevelIndex >= officialPlayableLevels.length) {
                        currentLevelIndex = 0; // Loop back to first level or show completion message
                        if (messageBox) messageBox.textContent = "You've completed all official levels!";
                        setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                    }
                    initializeGame();
                }
            });
            if (editCurrentLevelButton) editCurrentLevelButton.addEventListener('click', () => {
                // Set buildGrid to current mazeGrid for editing
                buildGrid = JSON.parse(JSON.stringify(mazeGrid)); // Deep copy
                updatePlayerAndEndFromBuildGrid(); // Ensure player/end are correctly set for build mode
                editingLevelId = currentLevelId; // Set the ID of the level being edited
                hideAllModals();
                currentGameType = GAME_MODES.BUILD;
                showScreen('buildModeArea');
                if (buildMessageBox) buildMessageBox.textContent = `Editing level: "${currentLevelName}"`;
            });
            if (backToMainMenuButtonGame) backToMainMenuButtonGame.addEventListener('click', () => showScreen('startScreen'));

            // Build Mode Area Buttons
            if (clearBuildGridButton) clearBuildGridButton.addEventListener('click', () => {
                initBuildGrid();
                drawBuild();
                if (buildMessageBox) buildMessageBox.textContent = "Grid cleared!";
            });
            if (saveLevelButton) saveLevelButton.addEventListener('click', saveLevel);
            if (publishLevelButton) publishLevelButton.addEventListener('click', publishLevel);
            if (backToMainMenuButtonBuild) backToMainMenuButtonBuild.addEventListener('click', () => showScreen('startScreen'));

            // Build Tools
            if (toolEraser) toolEraser.addEventListener('click', () => selectBuildTool('eraser'));
            if (toolWall) toolWall.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.WALL));
            if (toolPath) toolPath.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.PATH));
            if (toolPlayer) toolPlayer.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.PLAYER_START));
            if (toolWinpad) toolWinpad.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.WINPAD));
            if (toolDamagingBlock) toolDamagingBlock.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.DAMAGING_BLOCK));
            if (toolPushBlock) toolPushBlock.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.PUSH_BLOCK));
            if (toolCustomBlock) toolCustomBlock.addEventListener('click', () => showCustomBlockEditorModal()); // Opens custom block editor
            if (toolSelection) toolSelection.addEventListener('click', () => selectBuildTool('selection'));

            // Selection Actions
            if (fillSelectionButton) fillSelectionButton.addEventListener('click', () => fillSelection(lastSelectedDrawingTool));
            if (clearSelectionButton) clearSelectionButton.addEventListener('click', () => fillSelection(BLOCK_TYPES.PATH));
            if (exitSelectionButton) exitSelectionButton.addEventListener('click', () => selectBuildTool(lastSelectedDrawingTool)); // Return to last drawing tool

            // Custom Block Editor Buttons
            if (saveCustomBlockDefinitionButton) saveCustomBlockDefinitionButton.addEventListener('click', saveCustomBlockDefinition);
            if (deleteCustomBlockDefinitionButton) deleteCustomBlockDefinitionButton.addEventListener('click', async () => {
                if (editingCustomBlockId) {
                    if (window.confirm(`Are you sure you want to delete custom block definition '${editingCustomBlockId}'?`)) {
                        try {
                            await deleteDoc(doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/custom_block_definitions`, editingCustomBlockId));
                            if (messageBox) messageBox.textContent = `Custom Block '${editingCustomBlockId}' deleted.`;
                            setTimeout(() => { if (messageBox) messageBox.textContent = ""; }, 3000);
                            loadCustomBlockDefinitionsFromFirestore(); // Refresh the list
                            // If the deleted block was currently selected, clear selection
                            if (currentSelectedCustomBlockId === editingCustomBlockId) {
                                currentSelectedCustomBlockId = null;
                                if (buildMessageBox) buildMessageBox.textContent = "Custom Block selection cleared.";
                            }
                            // If the deleted block was being edited, clear editor fields
                            if (editingCustomBlockId === editingCustomBlockId) { // Changed condition to match the variable
                                customBlockNameInput.value = '';
                                customBlockColorPicker.value = CUSTOM_BLOCK_DEFAULT_COLOR;
                                customBlockScriptInput.value = '';
                                editingCustomBlockId = null;
                                deleteCustomBlockDefinitionButton.style.display = 'none';
                            }
                        } catch (error) {
                            console.error("Error deleting custom block definition:", error);
                            if (customBlockEditorModalOverlay) customBlockEditorModalOverlay.querySelector('.modal-content p').textContent = `Error deleting definition: ${error.message}`;
                        }
                    }
                }
            });
            if (closeCustomBlockEditorButton) closeCustomBlockEditorButton.addEventListener('click', () => {
                hideModal(customBlockEditorModalOverlay);
                // Reset editor fields and editing state when closing
                customBlockNameInput.value = '';
                customBlockColorPicker.value = CUSTOM_BLOCK_DEFAULT_COLOR;
                customBlockScriptInput.value = '';
                editingCustomBlockId = null;
                deleteCustomBlockDefinitionButton.style.display = 'none';
            });


            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (gamePlayArea && gamePlayArea.classList.contains('active') && !gameWon) {
                    // Prevent default scrolling behavior for arrow keys and space
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(e.code)) {
                        e.preventDefault();
                    }
                    switch (e.code) {
                        case 'ArrowUp':
                        case 'KeyW':
                            movePlayer(0, -1);
                            break;
                        case 'ArrowDown':
                        case 'KeyS':
                            movePlayer(0, 1);
                            break;
                        case 'ArrowLeft':
                        case 'KeyA':
                            movePlayer(-1, 0);
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            movePlayer(1, 0);
                            break;
                    }
                }
            });

            // Touch controls (drag to reposition)
            let isDraggingTouchControls = false;
            let touchOffsetX, touchOffsetY;

            if (touchControls) {
                touchControls.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('touch-button')) return; // Don't drag if tapping a button
                    isDraggingTouchControls = true;
                    const rect = touchControls.getBoundingClientRect();
                    touchOffsetX = e.touches[0].clientX - rect.left;
                    touchOffsetY = e.touches[0].clientY - rect.top;
                    touchControls.style.cursor = 'grabbing';
                    e.preventDefault(); // Prevent scrolling
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isDraggingTouchControls) return;
                    e.preventDefault(); // Prevent scrolling while dragging

                    const newX = e.touches[0].clientX - touchOffsetX;
                    const newY = e.touches[0].clientY - touchOffsetY;

                    // Constrain within viewport
                    const maxX = window.innerWidth - touchControls.offsetWidth;
                    const maxY = window.innerHeight - touchControls.offsetHeight;

                    const finalX = Math.min(Math.max(0, newX), maxX);
                    const finalY = Math.min(Math.max(0, newY), maxY);

                    touchControls.style.left = `${finalX}px`;
                    touchControls.style.top = `${finalY}px`;
                });

                document.addEventListener('touchend', () => {
                    if (isDraggingTouchControls) {
                        isDraggingTouchControls = false;
                        touchControls.style.cursor = 'grab';
                        // Save position to localStorage
                        localStorage.setItem('touchControlsPosition', JSON.stringify({
                            left: touchControls.style.left,
                            top: touchControls.style.top
                        }));
                    }
                });

                // Touch button actions
                touchControls.querySelectorAll('.touch-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const direction = e.target.dataset.direction;
                        switch (direction) {
                            case 'up': movePlayer(0, -1); break;
                            case 'down': movePlayer(0, 1); break;
                            case 'left': movePlayer(-1, 0); break;
                            case 'right': movePlayer(1, 0); break;
                        }
                    });
                });
            }

            // Position touch controls on load
            positionTouchControls();

            // Handle canvas drawing for build mode
            if (buildCanvas) {
                buildCanvas.addEventListener('mousedown', handleBuildCanvasInteraction);
                buildCanvas.addEventListener('mousemove', handleBuildCanvasInteraction);
                buildCanvas.addEventListener('mouseup', handleBuildCanvasInteraction);
                // Prevent context menu on right-click for canvas
                buildCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            // Initial setup
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Listen for Firebase Auth Ready event before loading user data
            document.addEventListener('firebaseAuthReady', () => {
                console.log("Firebase Auth is ready. Loading user profile and data.");
                loadUserProfile();
                fetchOfficialPlayableLevels();
                fetchDailyLevel();
                loadCustomBlockDefinitionsFromFirestore(); // Load definitions after auth is ready
            });

            // Show the start screen initially
            showScreen('startScreen');
        };

        // Function to position touch controls, loading from localStorage if available
        function positionTouchControls() {
            if (touchControls) {
                const savedPosition = localStorage.getItem('touchControlsPosition');
                if (savedPosition) {
                    const pos = JSON.parse(savedPosition);
                    touchControls.style.left = pos.left;
                    touchControls.style.top = pos.top;
                } else {
                    // Default position if not saved
                    touchControls.style.left = '20px';
                    touchControls.style.bottom = '20px'; // Use bottom for initial placement
                    touchControls.style.top = 'auto'; // Clear top if bottom is used
                }
            }
        }
    </script>
</body>
</html>
