<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Maze Game with Button & Moving Block</title>
<style>
  body {
    margin: 0; padding: 0;
    display: flex; flex-direction: column; align-items: center;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #gameCanvas {
    border: 1px solid black;
    margin-top: 10px;
    cursor: crosshair;
  }
  #controls {
    margin-top: 10px;
  }
  #buildControls {
    margin-top: 10px;
  }
  button.selected {
    background-color: #4CAF50;
    color: white;
  }
  .admin {
    color: red;
  }
</style>
</head>
<body>

<h1>Maze Game with Button & Moving Block</h1>

<div id="controls">
  <button id="toggleBuildBtn">Enter Build Mode</button>
  <div id="buildControls" style="display:none;">
    <button data-block="wall" id="drawWallBtn">Draw Wall</button>
    <button data-block="design" id="drawDesignBtn">Design Block</button>
    <button data-block="movable" id="drawMovableBtn">Movable Block</button>
    <button data-block="player" id="drawPlayerBtn">Player</button>
    <button data-block="win" id="drawWinBtn">Win</button>
    <button data-block="button" id="drawButtonBtn">Button Block</button>
    <button data-block="auto" id="drawAutoBtn">Auto-Move Block</button>
    <button data-block="erase" id="eraseBtn">Erase</button>
  </div>
</div>

<canvas id="gameCanvas" width="600" height="600"></canvas>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const cols = 20;
  const rows = 20;
  const cellSize = canvas.width / cols;

  // Maze blocks: empty, wall, design (non-solid gray), movable (blue), player, win, button, auto
  const blockTypes = {
    empty: {color: "white", solid: false, movable: false},
    wall: {color: "black", solid: true, movable: false},
    design: {color: "gray", solid: false, movable: false},
    movable: {color: "blue", solid: true, movable: true},
    player: {color: "green", solid: false, movable: false},
    win: {color: "gold", solid: false, movable: false},
    button: {color: "orange", solid: false, movable: false},
    auto: {color: "purple", solid: true, movable: true, autoMove: true},
  };

  let maze = [];
  let player = {x: 0, y: 0};
  let win = {x: cols-1, y: rows-1};

  // For auto-moving blocks
  let autoBlocks = [];

  let buildMode = false;
  let currentDrawBlock = "wall";
  let isDrawing = false;

  // Track keys pressed
  let keys = {};
  const MOVE_DELAY = 6;
  let moveCooldown = 0;

  // Toggles for demo: we toggle solid/movable property of movable blocks on button press
  let movableBlocksSolid = true;

  function initMazeEmpty() {
    maze = [];
    for(let x=0; x<cols; x++) {
      maze[x] = [];
      for(let y=0; y<rows; y++) {
        maze[x][y] = "empty";
      }
    }
    // Clear autoBlocks list
    autoBlocks = [];

    // Place player and win in random positions on empty cells
    player = placeRandom("player");
    win = placeRandom("win");
  }

  function placeRandom(type) {
    while(true) {
      const x = Math.floor(Math.random() * cols);
      const y = Math.floor(Math.random() * rows);
      if(maze[x][y] === "empty" && !(player.x === x && player.y === y) && !(win.x === x && win.y === y)) {
        if(type === "player") return {x,y};
        if(type === "win") return {x,y};
        maze[x][y] = type;
        if(type === "auto") autoBlocks.push({x,y,dir:getRandomDir()});
        return {x,y};
      }
    }
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let x=0; x<cols; x++) {
      for(let y=0; y<rows; y++) {
        const type = maze[x][y];
        if(type === "empty") {
          ctx.fillStyle = blockTypes.empty.color;
        } else {
          let color = blockTypes[type]?.color || "magenta";
          if(type === "movable") {
            // Reflect current toggle state for movable blocks' solidity with alpha
            ctx.fillStyle = movableBlocksSolid ? color : "rgba(0,0,255,0.5)";
          } else {
            ctx.fillStyle = color;
          }
        }
        ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);

        // Draw grid lines for clarity
        ctx.strokeStyle = "lightgray";
        ctx.strokeRect(x*cellSize, y*cellSize, cellSize, cellSize);
      }
    }
    // Draw player and win on top
    ctx.fillStyle = blockTypes.player.color;
    ctx.fillRect(player.x*cellSize, player.y*cellSize, cellSize, cellSize);
    ctx.fillStyle = blockTypes.win.color;
    ctx.fillRect(win.x*cellSize, win.y*cellSize, cellSize, cellSize);
  }

  // Check if position is within maze and not solid (consider current movable block toggle)
  function canMoveTo(x,y) {
    if(x < 0 || y < 0 || x >= cols || y >= rows) return false;
    let type = maze[x][y];
    if(type === "empty" || type === "design" || type === "button") return true;
    if(type === "movable") return !movableBlocksSolid ? true : false;
    if(type === "auto") return false; // solid
    if(type === "wall") return false;
    return true;
  }

  function movePlayer(dx, dy) {
    if(moveCooldown > 0) return;
    let nx = player.x + dx;
    let ny = player.y + dy;
    if(canMoveTo(nx, ny)) {
      player.x = nx;
      player.y = ny;
      moveCooldown = MOVE_DELAY;
      checkButtonTrigger(nx, ny);
      checkWin();
      draw();
    }
  }

  function checkWin() {
    if(player.x === win.x && player.y === win.y) {
      alert("You win!");
      // Reset player and win random
      player = placeRandom("player");
      win = placeRandom("win");
      draw();
    }
  }

  function checkButtonTrigger(x,y) {
    if(maze[x][y] === "button") {
      movableBlocksSolid = !movableBlocksSolid;
      alert("Button pressed! Movable blocks solidity toggled: " + movableBlocksSolid);
      draw();
    }
  }

  // Auto-moving blocks move every fixed frames randomly if possible
  const AUTO_MOVE_INTERVAL = 30;
  let autoMoveCounter = 0;

  function moveAutoBlocks() {
    autoBlocks.forEach(block => {
      // Attempt to move block in its direction if possible
      const nx = block.x + block.dir.dx;
      const ny = block.y + block.dir.dy;
      if(canAutoMoveTo(nx, ny)) {
        maze[block.x][block.y] = "empty";
        block.x = nx;
        block.y = ny;
        maze[block.x][block.y] = "auto";
      } else {
        block.dir = getRandomDir();
      }
    });
  }

  function canAutoMoveTo(x,y) {
    if(x < 0 || y < 0 || x >= cols || y >= rows) return false;
    const type = maze[x][y];
    if(type === "empty" || type === "design" || type === "button") return true;
    // Avoid player, win, walls, movable, auto blocks
    return false;
  }

  function getRandomDir() {
    const dirs = [
      {dx:1, dy:0},
      {dx:-1, dy:0},
      {dx:0, dy:1},
      {dx:0, dy:-1},
    ];
    return dirs[Math.floor(Math.random()*dirs.length)];
  }

  // --- Build mode drawing ---

  function canvasCoordsToCell(mx, my) {
    return {
      x: Math.floor(mx / cellSize),
      y: Math.floor(my / cellSize),
    };
  }

  function drawBlockAt(x,y) {
    if(x < 0 || y < 0 || x >= cols || y >= rows) return;

    // Prevent placing player or win on non-empty cells
    if(currentDrawBlock === "player") {
      if(!(player.x === x && player.y === y)) {
        player = {x,y};
        draw();
      }
      return;
    }
    if(currentDrawBlock === "win") {
      if(!(win.x === x && win.y === y)) {
        win = {x,y};
        draw();
      }
      return;
    }

    // For erase, set empty
    if(currentDrawBlock === "erase") {
      // Remove from autoBlocks if any
      if(maze[x][y] === "auto") {
        autoBlocks = autoBlocks.filter(b => !(b.x === x && b.y === y));
      }
      maze[x][y] = "empty";
      draw();
      return;
    }

    // Prevent placing blocks over player or win
    if((player.x === x && player.y === y) || (win.x === x && win.y === y)) {
      return;
    }

    // Place block normally
    if(currentDrawBlock === "auto") {
      // Add auto block if empty
      if(maze[x][y] === "empty") {
        maze[x][y] = "auto";
        autoBlocks.push({x,y,dir:getRandomDir()});
        draw();
      }
      return;
    }

    if(maze[x][y] === "auto") {
      // remove from autoBlocks if overwriting
      autoBlocks = autoBlocks.filter(b => !(b.x === x && b.y === y));
    }
    maze[x][y] = currentDrawBlock;
    draw();
  }

  // Mouse handling for drawing blocks
  canvas.addEventListener("mousedown", e => {
    if(!buildMode) return;
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const cell = canvasCoordsToCell(mx,my);
    drawBlockAt(cell.x, cell.y);
  });

  canvas.addEventListener("mousemove", e => {
    if(!buildMode || !isDrawing) return;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const cell = canvasCoordsToCell(mx,my);
    drawBlockAt(cell.x, cell.y);
  });

  window.addEventListener("mouseup", e => {
    isDrawing = false;
  });

  // Keyboard controls for movement
  window.addEventListener("keydown", e => {
    if(buildMode) return;
    if(moveCooldown > 0) return;
    switch(e.key) {
      case "ArrowUp":
      case "w":
      case "W":
        movePlayer(0,-1);
        break;
      case "ArrowDown":
      case "s":
      case "S":
        movePlayer(0,1);
        break;
      case "ArrowLeft":
      case "a":
      case "A":
        movePlayer(-1,0);
        break;
      case "ArrowRight":
      case "d":
      case "D":
        movePlayer(1,0);
        break;
    }
  });

  // Toggle build mode button & buttons
  const toggleBuildBtn = document.getElementById("toggleBuildBtn");
  const buildControls = document.getElementById("buildControls");
  toggleBuildBtn.addEventListener("click", () => {
    buildMode = !buildMode;
    buildControls.style.display = buildMode ? "block" : "none";
    toggleBuildBtn.textContent = buildMode ? "Exit Build Mode" : "Enter Build Mode";
  });

  // Draw block type buttons
  const drawButtons = document.querySelectorAll("#buildControls button[data-block]");
  drawButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      currentDrawBlock = btn.dataset.block;
      drawButtons.forEach(b => b.classList.remove("selected"));
      btn.classList.add("selected");
    });
  });

  // Init maze & draw
  initMazeEmpty();
  draw();

  // Game loop to move auto blocks and update cooldown
  function gameLoop() {
    if(!buildMode) {
      if(moveCooldown > 0) moveCooldown--;
      autoMoveCounter++;
      if(autoMoveCounter >= AUTO_MOVE_INTERVAL) {
        moveAutoBlocks();
        autoMoveCounter = 0;
        draw();
      }
    }
    requestAnimationFrame(gameLoop);
  }
  gameLoop();

})();
</script>

</body>
</html>
