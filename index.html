<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LtpMer's Maze Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // If you want to use Analytics, uncomment the line below and ensure 'getAnalytics' is imported above.
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // --- IMPORTANT: FOR EXTERNAL HOSTING, REPLACE THIS WITH YOUR ACTUAL FIREBASE CONFIG ---
        // You MUST ensure this 'myFirebaseConfig' object contains your OWN Firebase project's configuration.
        // This configuration can be found in your Firebase project settings (web app section).
        // The 'projectId' field is crucial for connecting to your Firestore database.
        
        const myFirebaseConfig = {
          apiKey: "AIzaSyAB3UcTTArjYHrhcDFo780HsK2gIYVGXjQ",
          authDomain: "mazegame-27b3f.firebaseapp.com",
          projectId: "mazegame-27b3f",
          storageBucket: "mazegame-27b3f.firebasestorage.app",
          messagingSenderId: "632041065509",
          appId: "1:632041065509:web:659ed37bf4475df8da83cc",
          measurementId: "G-EFMZ0KCNM5" // Optional: Include if you want Firebase Analytics
        };
        // This line is crucial: it makes your Firebase config globally accessible to the game logic.
        // For Canvas environment, __firebase_config is often provided as a string.
        // We'll prioritize the Canvas-provided __firebase_config if available.
        // If __firebase_config from Canvas is undefined, it falls back to myFirebaseConfig.
        window.__firebase_config = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : myFirebaseConfig;
        
        // --------------------------------------------------------------------------------------

        // Global variables for Firebase (will be populated by the environment or manually)
        // If running outside Canvas, __app_id and __initial_auth_token will be undefined.
        // The game will use the manually provided window.__firebase_config.
        window.__app_id = typeof __app_id !== 'undefined' ? __app_id : (window.__firebase_config ? window.__firebase_config.appId : 'default-app-id');
        window.__initial_auth_token = typeof __initial_auth_token !== 'undefined' ? window.__initial_auth_token : null;

        console.log("Firebase config being used for initialization:", window.__firebase_config); // Added for debugging
        console.log("App ID being used:", window.__app_id); // Added for debugging

        // Initialize Firebase
        if (window.__firebase_config && window.__firebase_config.projectId) { // Added check for projectId
            try {
                window.firebaseApp = initializeApp(window.__firebase_config);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                // If you enabled Analytics, uncomment the line below:
                // window.analytics = getAnalytics(window.firebaseApp);

                // Sign in anonymously or with custom token
                if (window.__initial_auth_token) {
                    signInWithCustomToken(window.auth, window.__initial_auth_token)
                        .then(() => {
                            console.log("Firebase signed in with custom token.");
                            window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                            document.dispatchEvent(new Event('firebaseAuthReady'));
                        })
                        .catch((error) => {
                            console.error("Error signing in with custom token:", error);
                            signInAnonymously(window.auth)
                                .then(() => {
                                    console.log("Firebase signed in anonymously.");
                                    window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                                    document.dispatchEvent(new Event('firebaseAuthReady'));
                                })
                                .catch((anonError) => {
                                    console.error("Error signing in anonymously:", anonError);
                                    window.userId = crypto.randomUUID(); // Fallback to random ID
                                    document.dispatchEvent(new Event('firebaseAuthReady'));
                                });
                        });
                } else {
                    signInAnonymously(window.auth)
                        .then(() => {
                            console.log("Firebase signed in anonymously.");
                            window.userId = window.auth.currentUser?.uid || crypto.randomUUID();
                            document.dispatchEvent(new Event('firebaseAuthReady'));
                        })
                        .catch((error) => {
                            console.error("Error signing in anonymously:", error);
                            window.userId = crypto.randomUUID(); // Fallback to random ID
                            document.dispatchEvent(new Event('firebaseAuthReady'));
                        });
                }

                onAuthStateChanged(window.auth, (user) => {
                    if (user) {
                        window.userId = user.uid;
                        console.log("Auth state changed, user ID:", window.userId);
                    } else {
                        console.log("Auth state changed, no user.");
                        // If user logs out, userId might need to be re-evaluated or handled
                    }
                });
            } catch (initError) {
                console.error("Error initializing Firebase App:", initError);
                console.warn("Running without Firebase features due to initialization error.");
                window.userId = crypto.randomUUID(); // Generate a random ID if Firebase initialization fails
                document.dispatchEvent(new Event('firebaseAuthReady'));
            }
        } else {
            console.warn("Firebase config not found or projectId missing. Running without Firebase features.");
            window.userId = crypto.randomUUID(); // Generate a random ID if Firebase is not configured
            document.dispatchEvent(new Event('firebaseAuthReady'));
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c; /* Dark background */
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #e2e8f0; /* Light text */
            position: relative; /* Needed for absolute positioning of info button */
            /* Removed overflow: hidden; to allow scrolling */
        }

        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90%;
            width: 700px; /* Max width for larger screens */
            gap: 20px;
            position: relative; /* For z-index */
        }

        h1 {
            color: #63b3ed; /* Blue title */
            margin-bottom: 15px;
            font-size: 2.5rem;
            text-align: center;
        }

        canvas {
            background-color: #f0f0f0; /* Light grey maze background for paths */
            border: 5px solid #4a5568; /* Darker border for canvas */
            border-radius: 10px;
            display: block;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            justify-content: center;
            gap: 15px;
            width: 100%;
        }

        button {
            background-color: #48bb78; /* Green button */
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            flex-grow: 1; /* Allow buttons to grow */
            max-width: 200px; /* Adjust max-width for better distribution */
        }

        button:hover {
            background-color: #38a169; /* Darker green on hover */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Specific button styles */
        .start-screen-button { /* For Play, Customization, Menu on start screen */
            background-color: #63b3ed; /* Blue for main buttons */
            font-weight: bold;
            font-size: 1.8rem; /* Larger font for main buttons */
            padding: 20px 40px;
            border-radius: 15px;
            max-width: 300px;
            min-width: 150px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        .start-screen-button:hover {
            background-color: #4299e1;
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        .start-screen-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #customizationButtonStart, #menuButtonStart, #leaderboardButton { /* Added leaderboard button */
            background-color: #f6ad55; /* Orange for Customization */
            font-size: 1.2rem; /* Smaller than Play, larger than game controls */
            padding: 15px 30px;
            max-width: 250px;
        }
        #customizationButtonStart:hover, #menuButtonStart:hover, #leaderboardButton:hover {
            background-color: #ed8936;
        }

        #menuButtonStart {
            background-color: #a0aec0; /* Grey for Menu */
        }
        #menuButtonStart:hover {
            background-color: #718096;
        }

        /* Daily Level Display */
        .daily-level-container {
            background-color: #4a5568; /* Darker grey for daily level box */
            border-radius: 10px;
            padding: 15px 20px;
            margin-top: 20px;
            width: 80%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .daily-level-container h3 {
            color: #63b3ed;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }
        .daily-level-container p {
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        .daily-level-container button {
            background-color: #4CAF50;
            font-size: 1.1rem;
            padding: 10px 20px;
            max-width: 250px;
        }
        .daily-level-container button:hover {
            background-color: #388E3C;
        }


        /* Touch controls for mobile */
        .touch-controls {
            display: none; /* Hidden by default, shown on smaller screens */
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 10px;
            margin-top: 20px;
            width: 200px;
            height: 200px;
            justify-items: center;
            align-items: center;
        }

        .touch-button {
            background-color: #63b3ed; /* Blue for touch buttons */
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .touch-button:active {
            background-color: #4299e1;
            transform: scale(0.95);
        }

        .touch-button.up { grid-area: up; }
        .touch-button.down { grid-area: down; }
        .touch-button.left { grid-area: left; }
        .touch-button.right { grid-area: right; }

        /* Info and Login Buttons in corner */
        .corner-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .corner-buttons button {
            background-color: #f6ad55; /* Orange color */
            color: #2d3748;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            cursor: pointer;
            border: none;
            min-width: unset;
            text-align: center;
            flex-grow: 0; /* Prevent them from growing */
            max-width: unset; /* Remove max-width constraint */
        }

        .corner-buttons button:hover {
            background-color: #ed8936;
            transform: translateY(-1px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }
        .corner-buttons button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #loginButton.logged-in {
            background-color: #e53e3e; /* Red for logout */
        }
        #loginButton.logged-in:hover {
            background-color: #c53030;
        }


        /* General Modal Styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100; /* Ensure it's on top of everything */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            text-align: center;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            color: #e2e8f0;
        }

        .modal-overlay.show .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-content h2 {
            color: #63b3ed;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .modal-content p {
            line-height: 1.6;
            margin-bottom: 25px;
            font-size: 1.1rem;
        }

        .modal-content .close-button {
            background-color: #e53e3e; /* Red close button */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            border: none;
        }

        .modal-content .close-button:hover {
            background-color: #c53030;
            transform: translateY(-1px);
        }

        /* Game State Specific Displays */
        .start-screen, .game-play-area, .build-mode-area {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            justify-content: center;
            gap: 20px;
        }

        .start-screen.active, .game-play-area.active, .build-mode-area.active {
            display: flex; /* Shown when active */
        }

        /* Styles for buttons inside menu modal */
        .menu-modal-buttons button {
            background-color: #4CAF50; /* Green for menu options */
            margin-bottom: 10px;
            max-width: 300px;
        }
        .menu-modal-buttons button:hover {
            background-color: #388E3C;
        }
        #clearBuildGridButton {
            background-color: #e53e3e; /* Red for clear button */
        }
        #clearBuildGridButton:hover {
            background-color: #c53030;
        }

        /* Build Mode Tool Buttons */
        .build-tools {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            margin-bottom: 15px;
            width: 100%;
        }
        .build-tools button {
            background-color: #63b3ed; /* Blue for tools */
            flex-grow: 0;
            max-width: 120px;
            padding: 8px 15px;
            font-size: 0.9rem;
        }
        .build-tools button.active-tool {
            background-color: #4299e1;
            box-shadow: 0 0 0 3px #4299e1, 0 0 0 6px #63b3ed; /* Highlight active tool */
        }
        #saveLevelButton, #publishLevelButton { /* Added publish button */
            background-color: #4CAF50; /* Green for save */
            font-weight: bold;
            font-size: 1.1rem;
            padding: 10px 20px;
        }
        #saveLevelButton:hover, #publishLevelButton:hover {
            background-color: #388E3C;
        }

        /* Customization Modal Styles */
        .customization-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        .customization-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .customization-option label {
            flex-basis: 40%;
            text-align: left;
            font-size: 1.1rem;
        }
        .customization-option input[type="color"] {
            flex-basis: 55%;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            padding: 0;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .customization-option input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .customization-option input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 8px;
        }
        .customization-option input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 8ä¸€å±¤;
        }

        /* Level Lists (My Levels & Community Levels) */
        .level-list-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            width: 100%;
            text-align: left;
        }
        .level-list-container div {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #4a5568;
        }
        .level-list-container div:last-child {
            border-bottom: none;
        }
        .level-list-container button {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 0.9rem;
            max-width: 80px;
            flex-shrink: 0;
        }
        .level-list-container .level-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .level-list-container .play-level-button {
            background-color: #68d391;
        }
        .level-list-container .play-level-button:hover {
            background-color: #48bb78;
        }
        .level-list-container .delete-level-button {
            background-color: #e53e3e;
        }
        .level-list-container .delete-level-button:hover {
            background-color: #c53030;
        }
        .level-list-container .set-daily-button { /* New style for admin button */
            background-color: #FFD700; /* Gold */
            color: #2d3748;
        }
        .level-list-container .set-daily-button:hover {
            background-color: #DAA520; /* Darker Gold */
        }
        /* New style for "Set as Official" button */
        .level-list-container .set-official-button {
            background-color: #805AD5; /* Purple */
            color: white;
        }
        .level-list-container .set-official-button:hover {
            background-color: #6B46C1;
        }

        /* Leaderboard Specific Styles */
        .leaderboard-list-container {
            max-height: 300px; /* Make it scrollable */
            overflow-y: auto;
            border: 1px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            margin-top: 15px;
            width: 100%;
            text-align: left;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px dashed #4a5568;
        }
        .leaderboard-entry:last-child {
            border-bottom: none;
        }
        .leaderboard-entry .rank {
            font-weight: bold;
            color: #63b3ed;
            width: 30px;
            flex-shrink: 0;
        }
        .leaderboard-entry .player-name {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px;
        }
        .leaderboard-entry .level-name-lb {
            font-size: 0.9em;
            color: #a0aec0;
            margin-right: 10px;
        }
        .leaderboard-entry .time {
            font-weight: bold;
            color: #4CAF50;
            flex-shrink: 0;
        }

        /* Login Modal specific styles */
        .login-form-group {
            margin-bottom: 15px;
            text-align: left;
        }
        .login-form-group label {
            display: block;
            margin-bottom: 5px;
            color: #e2e8f0;
        }
        .login-form-group input {
            width: calc(100% - 20px);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: #e2e8f0;
            font-size: 1rem;
        }
        .login-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        .login-buttons button {
            flex-grow: 1;
            max-width: 150px;
        }
        .login-buttons #loginSubmitButton {
            background-color: #63b3ed;
        }
        .login-buttons #loginSubmitButton:hover {
            background-color: #4299e1;
        }
        .login-buttons #loginCancelButton {
            background-color: #a0aec0;
        }
        .login-buttons #loginCancelButton:hover {
            background-color: #718096;
        }

        /* Specific style for the Eraser button */
        #toolEraser {
            background-color: #e53e3e; /* Red color for eraser */
        }
        #toolEraser:hover {
            background-color: #c53030; /* Darker red on hover */
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            .game-container {
                padding: 20px;
                width: 100%;
            }
            .message-box {
                font-size: 1rem;
                padding: 10px 15px;
            }
            button {
                padding: 10px 20px;
                font-size: 1rem;
            }
            .touch-controls {
                display: grid; /* Show touch controls on small screens */
            }
            .corner-buttons {
                top: 10px;
                right: 10px;
                gap: 5px;
            }
            .corner-buttons button {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            .modal-content {
                padding: 20px;
            }
            .modal-content h2 {
                font-size: 1.7rem;
            }
            .modal-content p {
                font-size: 1rem;
            }
            .button-row {
                flex-direction: column; /* Stack buttons vertically on small screens */
            }
            button {
                max-width: 100%; /* Full width for stacked buttons */
            }
            .start-screen-button {
                font-size: 1.5rem;
                padding: 15px 30px;
            }
            #customizationButtonStart, #menuButtonStart, #leaderboardButton {
                font-size: 1.1rem;
                padding: 12px 25px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Start Screen -->
        <div id="startScreen" class="start-screen">
            <h1>LtpMer's Maze Game</h1>
            <button id="playButton" class="start-screen-button">Play</button>
            <button id="customizationButtonStart" class="start-screen-button">Customization</button>
            <button id="menuButtonStart" class="start-screen-button">Menu</button>
            <button id="leaderboardButton" class="start-screen-button">Leaderboard</button> <!-- New Leaderboard Button -->

            <div id="dailyLevelContainer" class="daily-level-container" style="display: none;">
                <h3>Daily Level</h3>
                <p id="dailyLevelName">Loading daily level...</p>
                <button id="playDailyLevelButton">Play Daily Level</button>
            </div>
        </div>

        <!-- Game Play Area (for levels, random maze, random blocks) -->
        <div id="gamePlayArea" class="game-play-area">
            <canvas id="mazeCanvas"></canvas>
            <div class="message-box" id="messageBox">Use arrow keys or WASD to move!</div>
            <div class="controls">
                <div class="button-row">
                    <button id="nextLevelButton" style="display: none;">Next Level</button> <!-- Only for Level Mode -->
                    <button id="saveCurrentLevelButton">Save Current Level</button> <!-- New Save Current Level Button -->
                    <button id="backToMainMenuButtonGame">Back to Main Menu</button>
                </div>
                <div class="touch-controls">
                    <button class="touch-button up" data-direction="up">&#9650;</button>
                    <button class="touch-button left" data-direction="left">&#9664;</button>
                    <button class="touch-button right" data-direction="right">&#9654;</button>
                    <button class="touch-button down" data-direction="down">&#9660;</button>
                </div>
            </div>
        </div>

        <!-- Build Mode Area -->
        <div id="buildModeArea" class="build-mode-area">
            <h1>Build Mode</h1>
            <canvas id="buildCanvas"></canvas>
            <div class="message-box" id="buildMessageBox">Click to place/remove blocks!</div>
            <div class="controls">
                <div class="build-tools" id="drawingTools">
                    <button id="toolEraser">Eraser</button> <!-- New Eraser Tool -->
                    <button id="toolWall" class="active-tool">Wall</button>
                    <button id="toolPath">Path</button>
                    <button id="toolPlayer">Player</button>
                    <button id="toolWinpad">Win Pad</button>
                    <button id="toolTrigger">Trigger</button>
                    <button id="toolMovingBlock">Moving</button>
                    <button id="toolPushBlock">Push</button>
                    <button id="toolSelection">Selection</button> <!-- New Selection Tool -->
                </div>
                <div class="button-row" id="selectionActions" style="display: none;">
                    <button id="fillSelectionButton">Fill Selected (Current Tool)</button>
                    <button id="clearSelectionButton">Clear Selected (Path)</button>
                    <button id="exitSelectionButton">Exit Selection</button> <!-- New Exit Selection Button -->
                </div>
                <div class="button-row">
                    <button id="clearBuildGridButton">Clear Grid</button>
                    <button id="saveLevelButton">Save Level</button>
                    <button id="publishLevelButton">Publish Level</button> <!-- New Publish Button -->
                    <button id="backToMainMenuButtonBuild">Back to Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Info and Login Buttons in corner -->
    <div class="corner-buttons">
        <button id="loginButton">Login</button>
        <button id="infoButton">Info</button>
    </div>

    <!-- Info Modal -->
    <div id="infoModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Welcome to Maze Explorer!</h2>
            <p>
                Navigate the red player block to the green winpad.
                Use **Arrow Keys** or **WASD** to move.
                <br><br>
                **Play:** Jump straight into predefined levels.
                <br>
                **Customization:** Change game visuals.
                <br>
                **Menu:** Access other game modes like random generation, build mode, or saved levels.
            </p>
            <button class="close-button" id="closeInfoModalButton">Close</button>
        </div>
    </div>

    <!-- Customization Modal -->
    <div id="customizationModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Customization</h2>
            <div class="customization-options">
                <div class="customization-option">
                    <label for="playerColorPicker">Player Color:</label>
                    <input type="color" id="playerColorPicker">
                </div>
                <div class="customization-option">
                    <label for="wallColorPicker">Wall Color:</label>
                    <input type="color" id="wallColorPicker">
                </div>
                <div class="customization-option">
                    <label for="pathColorPicker">Path Color:</label>
                    <input type="color" id="pathColorPicker">
                </div>
            </div>
            <button class="close-button" id="closeCustomizationModalButton">Close</button>
        </div>
    </div>

    <!-- Menu Modal -->
    <div id="menuModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Menu</h2>
            <p id="userIdDisplay">User ID: Loading...</p>
            <p id="playerBricksDisplay">Bricks: ðŸ§± 0</p> <!-- New Bricks Display -->
            <p>Choose your game mode:</p>
            <div class="button-row menu-modal-buttons">
                <button id="startRandomMazeButton">Start Random Maze</button>
                <button id="startRandomBlocksButton">Start Random Blocks</button>
                <button id="buildModeButton">Build Mode</button>
            </div>
            <h3>My Levels</h3>
            <div id="myLevelsList" class="level-list-container">
                <!-- Levels will be loaded here -->
                Loading levels...
            </div>
            <button id="refreshMyLevelsButton">Refresh My Levels</button>
            <h3>Community Levels</h3>
            <p>Search and play levels created by others!</p>
            <div class="button-row menu-modal-buttons">
                <button id="searchLevelsButton">Search Levels</button>
            </div>
            <button class="close-button" id="closeMenuModalButton">Close</button>
        </div>
    </div>

    <!-- Login Modal -->
    <div id="loginModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Simulated Login</h2>
            <p>
                This is a **simulated login** for demonstration purposes.
                It does not connect to a real authentication server or store your password securely.
                Your entered Player Name will be displayed in the Menu.
            </p>
            <div class="login-form-group">
                <label for="playerNameInput">Player Name:</label>
                <input type="text" id="playerNameInput" placeholder="Enter your player name" autocomplete="username">
            </div>
            <div class="login-form-group">
                <label for="passwordInput">Password:</label>
                <input type="password" id="passwordInput" placeholder="Enter a password (not saved)" autocomplete="current-password">
            </div>
            <div class="login-buttons">
                <button id="loginSubmitButton">Login</button>
                <button id="loginCancelButton">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Community Levels Modal -->
    <div id="communityLevelsModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Community Levels</h2>
            <div id="communityLevelsList" class="level-list-container">
                Loading community levels...
            </div>
            <button id="refreshCommunityLevelsButton">Refresh Community Levels</button>
            <button class="close-button" id="closeCommunityLevelsModalButton">Close</button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboardModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <h2>Leaderboard</h2>
            <div id="leaderboardList" class="leaderboard-list-container">
                Loading leaderboard...
            </div>
            <button id="refreshLeaderboardButton">Refresh Leaderboard</button>
            <button class="close-button" id="closeLeaderboardModalButton">Close</button>
        </div>
    </div>

    <script type="module">
        // Import Firestore functions
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Get main UI elements
        const startScreen = document.getElementById('startScreen');
        const gamePlayArea = document.getElementById('gamePlayArea');
        const buildModeArea = document.getElementById('buildModeArea');
        const infoButton = document.getElementById('infoButton');
        const loginButton = document.getElementById('loginButton');

        // Get start screen buttons
        const playButton = document.getElementById('playButton');
        const customizationButtonStart = document.getElementById('customizationButtonStart');
        const menuButtonStart = document.getElementById('menuButtonStart');
        const leaderboardButton = document.getElementById('leaderboardButton');
        const dailyLevelContainer = document.getElementById('dailyLevelContainer');
        const dailyLevelName = document.getElementById('dailyLevelName');
        const playDailyLevelButton = document.getElementById('playDailyLevelButton');

        // Get game play area elements
        const mazeCanvas = document.getElementById('mazeCanvas');
        const mazeCtx = mazeCanvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const nextLevelButton = document.getElementById('nextLevelButton');
        const saveCurrentLevelButton = document.getElementById('saveCurrentLevelButton'); // New button
        const backToMainMenuButtonGame = document.getElementById('backToMainMenuButtonGame');
        const touchControls = document.querySelector('.touch-controls');

        // Get build mode area elements
        const buildCanvas = document.getElementById('buildCanvas');
        const buildCtx = buildCanvas.getContext('2d');
        const buildMessageBox = document.getElementById('buildMessageBox');
        const clearBuildGridButton = document.getElementById('clearBuildGridButton');
        const saveLevelButton = document.getElementById('saveLevelButton');
        const publishLevelButton = document.getElementById('publishLevelButton');
        const backToMainMenuButtonBuild = document.getElementById('backToMainMenuButtonBuild');

        // Modals
        const infoModalOverlay = document.getElementById('infoModalOverlay');
        const closeInfoModalButton = document.getElementById('closeInfoModalButton');
        const customizationModalOverlay = document.getElementById('customizationModalOverlay');
        const closeCustomizationModalButton = document.getElementById('closeCustomizationModalButton');
        const menuModalOverlay = document.getElementById('menuModalOverlay');
        const closeMenuModalButton = document.getElementById('closeMenuModalButton');
        const loginModalOverlay = document.getElementById('loginModalOverlay');
        const playerNameInput = document.getElementById('playerNameInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginSubmitButton = document.getElementById('loginSubmitButton');
        const loginCancelButton = document.getElementById('loginCancelButton');
        const communityLevelsModalOverlay = document.getElementById('communityLevelsModalOverlay');
        const communityLevelsList = document.getElementById('communityLevelsList');
        const refreshCommunityLevelsButton = document.getElementById('refreshCommunityLevelsButton');
        const closeCommunityLevelsModalButton = document.getElementById('closeCommunityLevelsModalButton');
        const leaderboardModalOverlay = document.getElementById('leaderboardModalOverlay');
        const leaderboardList = document.getElementById('leaderboardList');
        const refreshLeaderboardButton = document.getElementById('refreshLeaderboardButton');
        const closeLeaderboardModalButton = document.getElementById('closeLeaderboardModalButton');

        // Buttons inside Menu Modal
        const startRandomMazeButton = document.getElementById('startRandomMazeButton');
        const startRandomBlocksButton = document.getElementById('startRandomBlocksButton');
        const buildModeButton = document.getElementById('buildModeButton');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const playerBricksDisplay = document.getElementById('playerBricksDisplay');
        const myLevelsList = document.getElementById('myLevelsList');
        const refreshMyLevelsButton = document.getElementById('refreshMyLevelsButton');
        const searchLevelsButton = document.getElementById('searchLevelsButton');

        // Customization elements
        const playerColorPicker = document.getElementById('playerColorPicker');
        const wallColorPicker = document.getElementById('wallColorPicker');
        const pathColorPicker = document.getElementById('pathColorPicker');

        // Maze dimensions
        const MAZE_WIDTH = 31;
        const MAZE_HEIGHT = 31;
        let BLOCK_SIZE = 15;

        // Colors
        let PLAYER_COLOR = '#0000FF'; // Blue
        let WALL_COLOR = '#000000';
        let PATH_COLOR = '#f0f0f0';
        const END_COLOR = '#4CAF50';
        const TRIGGER_COLOR = '#8A2BE2';
        const MOVING_BLOCK_COLOR = '#4682B4';
        const PUSH_BLOCK_COLOR = '#FFD700';

        // Block Types
        const BLOCK_TYPES = {
            PATH: 0,
            WALL: 1,
            PLAYER_START: 2,
            WINPAD: 3,
            TRIGGER: 4,
            MOVING_BLOCK: 5,
            PUSH_BLOCK: 6
            // ERASER is handled by setting currentBuildTool to PATH
            // SELECTION is handled by setting currentBuildTool to 'selection' string
        };

        // Build Mode Tools
        const drawingToolsContainer = document.getElementById('drawingTools'); // New container for drawing tools
        const selectionActionsContainer = document.getElementById('selectionActions'); // New container for selection actions

        const toolWall = document.getElementById('toolWall');
        const toolEraser = document.getElementById('toolEraser'); 
        const toolPath = document.getElementById('toolPath'); 
        const toolPlayer = document.getElementById('toolPlayer');
        const toolWinpad = document.getElementById('toolWinpad');
        const toolTrigger = document.getElementById('toolTrigger');
        const toolMovingBlock = document.getElementById('toolMovingBlock');
        const toolPushBlock = document.getElementById('toolPushBlock');
        const toolSelection = document.getElementById('toolSelection'); // New Selection Tool
        const fillSelectionButton = document.getElementById('fillSelectionButton'); // New Fill Selection Button
        const clearSelectionButton = document.getElementById('clearSelectionButton'); // New Clear Selection Button
        const exitSelectionButton = document.getElementById('exitSelectionButton'); // New Exit Selection Button

        let currentBuildTool = BLOCK_TYPES.WALL; // The currently active tool for drawing/selection
        let lastSelectedDrawingTool = BLOCK_TYPES.WALL; // Stores the last non-selection tool chosen

        let isDrawing = false; // Flag for hold-click drawing
        let selectionStartPoint = null; // {x, y} for the first click in selection mode
        let selectionEndPoint = null;   // {x, y} for the current/last mouse position in selection mode
        let currentSelectionRect = null; // {x1, y1, x2, y2} normalized selection rectangle


        // Game state variables
        let mazeGrid = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(BLOCK_TYPES.WALL));
        let buildGrid = Array(MAZE_HEIGHT).fill(0).map(() => Array(MAZE_WIDTH).fill(BLOCK_TYPES.PATH));
        
        let player = { x: 0, y: 0 };
        let end = { x: MAZE_WIDTH - 1, y: MAZE_HEIGHT - 1 };
        let gameWon = false;
        let gameStartTime = 0;
        let currentLevelId = null; // ID of the level currently being played (for leaderboard)
        let currentLevelName = ''; // Name of the level currently being played (for leaderboard)

        let currentPlayerName = "Anonymous";
        let playerBricks = 0;

        // Game Modes
        const GAME_MODES = {
            LEVEL: 'level', // Now refers to official levels loaded from Firestore
            MAZE: 'maze',
            BLOCKS: 'blocks',
            BUILD: 'build',
            SAVED_LEVEL: 'saved_level',
            COMMUNITY_LEVEL: 'community_level'
        };
        let currentGameType = GAME_MODES.LEVEL;
        let currentLevelIndex = 0; // Index within the `officialPlayableLevels` array

        let officialPlayableLevels = []; // Array to hold levels fetched from Firestore for the "Play" button
        let currentDailyLevel = null;
        
        // Initializes the `mazeGrid` with all blocks set to `WALL`
        function initMazeGrid() {
            mazeGrid = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                const row = [];
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    row.push(BLOCK_TYPES.WALL); // Initialize all as walls
                }
                mazeGrid.push(row);
            }
        }

        // Initializes the `buildGrid` with all blocks set to `PATH` for a clear canvas
        function initBuildGrid() {
            buildGrid = [];
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                const row = [];
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    row.push(BLOCK_TYPES.PATH); // Initialize all as paths for building
                }
                buildGrid.push(row);
            }
            // Set default player and winpad for new build levels
            player = { x: 1, y: 1 };
            end = { x: MAZE_WIDTH - 2, y: MAZE_HEIGHT - 2 };
            buildGrid[player.y][player.x] = { type: BLOCK_TYPES.PLAYER_START }; // Store as object
            buildGrid[end.y][end.x] = { type: BLOCK_TYPES.WINPAD }; // Store as object
        }

        // Binary Tree Algorithm for Maze Generation
        function generateMaze() {
            initMazeGrid(); // Start with a grid full of walls

            for (let y = 1; y < MAZE_HEIGHT - 1; y += 2) {
                for (let x = 1; x < MAZE_WIDTH - 1; x += 2) {
                    mazeGrid[y][x] = BLOCK_TYPES.PATH;

                    const neighbors = [];
                    if (y > 1) { neighbors.push({ nx: x, ny: y - 2, wx: x, wy: y - 1 }); }
                    if (x > 1) { neighbors.push({ nx: x - 2, ny: y, wx: x - 1, wy: y }); }

                    if (neighbors.length > 0) {
                        const chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                        mazeGrid[chosen.wy][chosen.wx] = BLOCK_TYPES.PATH;
                    }
                }
            }
        }

        // Generates a random block pattern
        function generateBlocks() {
            initMazeGrid(); // Start with a grid full of walls

            const pathPercentage = 0.6;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (Math.random() < pathPercentage) {
                        mazeGrid[y][x] = BLOCK_TYPES.PATH;
                    }
                }
            }
        }

        // Loads a level into the mazeGrid from the officialPlayableLevels array
        function loadOfficialLevel(levelIndex) {
            const level = officialPlayableLevels[levelIndex];
            // Ensure grid data is handled correctly, it could be a string or array
            mazeGrid = typeof level.grid === 'string' ? JSON.parse(level.grid) : level.grid;
            player = { ...level.playerStart }; // Reset player position
            end = { ...level.winpadEnd };
            currentLevelId = level.id;
            currentLevelName = level.name;
        }

        // Helper function to get a random valid path position
        function getRandomPathPosition() {
            let randX, randY;
            let foundValidPosition = false;
            while (!foundValidPosition) {
                randX = Math.floor(Math.random() * MAZE_WIDTH);
                randY = Math.floor(Math.random() * MAZE_HEIGHT);

                if (currentGameType === GAME_MODES.MAZE) {
                    // Ensure random positions are on paths in a generated maze
                    if (randX % 2 === 0) { randX = (randX === MAZE_WIDTH - 1) ? randX - 1 : randX + 1; }
                    if (randY % 2 === 0) { randY = (randY === MAZE_HEIGHT - 1) ? randY - 1 : randY + 1; }
                    randX = Math.min(Math.max(randX, 0), MAZE_WIDTH - 1);
                    randY = Math.min(Math.max(randY, 0), MAZE_HEIGHT - 1);
                }
                
                // Check if it's a path, considering complex block objects
                const block = mazeGrid[randY] ? mazeGrid[randY][randX] : BLOCK_TYPES.WALL;
                const blockType = typeof block === 'object' ? block.type : block;

                if (blockType === BLOCK_TYPES.PATH) { 
                    foundValidPosition = true;
                }
            }
            return { x: randX, y: randY };
        }

        // Draws elements on the mazeCanvas (for game play)
        function drawGame() {
            if (!mazeGrid || mazeGrid.length === 0) {
                initMazeGrid(); // Ensure mazeGrid is initialized
            }

            mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            mazeCtx.fillStyle = PATH_COLOR;
            mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const block = mazeGrid[y] ? mazeGrid[y][x] : BLOCK_TYPES.WALL; // Default to wall if undefined
                    const blockType = typeof block === 'object' ? block.type : block;
                    let color = PATH_COLOR;

                    switch (blockType) {
                        case BLOCK_TYPES.WALL:
                            color = WALL_COLOR;
                            break;
                        case BLOCK_TYPES.PLAYER_START:
                            color = PLAYER_COLOR; // Player start point is player color
                            break;
                        case BLOCK_TYPES.WINPAD:
                            color = END_COLOR;
                            break;
                        case BLOCK_TYPES.TRIGGER:
                            color = TRIGGER_COLOR;
                            break;
                        case BLOCK_TYPES.MOVING_BLOCK:
                            color = MOVING_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.PUSH_BLOCK:
                            color = PUSH_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.PATH:
                        default:
                            color = PATH_COLOR;
                            break;
                    }
                    mazeCtx.fillStyle = color;
                    mazeCtx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            // Redraw player on top to ensure it is visible
            mazeCtx.fillStyle = PLAYER_COLOR;
            mazeCtx.fillRect(player.x * BLOCK_SIZE, player.y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            // Redraw end on top to ensure it is visible
            mazeCtx.fillStyle = END_COLOR;
            mazeCtx.fillRect(end.x * BLOCK_SIZE, end.y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        // Draws elements on the buildCanvas (for build mode)
        function drawBuild() {
            if (!buildGrid || buildGrid.length === 0) {
                initBuildGrid(); // Ensure buildGrid is initialized
            }

            buildCtx.clearRect(0, 0, buildCanvas.width, buildCanvas.height);
            buildCtx.fillStyle = PATH_COLOR;
            buildCtx.fillRect(0, 0, buildCanvas.width, buildCanvas.height);

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const block = buildGrid[y] ? buildGrid[y][x] : BLOCK_TYPES.PATH; // Default to path for build
                    const blockType = typeof block === 'object' ? block.type : block;
                    let color = PATH_COLOR;

                    switch (blockType) {
                        case BLOCK_TYPES.WALL:
                            color = WALL_COLOR;
                            break;
                        case BLOCK_TYPES.PLAYER_START:
                            color = PLAYER_COLOR;
                            break;
                        case BLOCK_TYPES.WINPAD:
                            color = END_COLOR;
                            break;
                        case BLOCK_TYPES.TRIGGER:
                            color = TRIGGER_COLOR;
                            break;
                        case BLOCK_TYPES.MOVING_BLOCK:
                            color = MOVING_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.PUSH_BLOCK:
                            color = PUSH_BLOCK_COLOR;
                            break;
                        case BLOCK_TYPES.PATH:
                        default:
                            color = PATH_COLOR;
                            break;
                    }
                    buildCtx.fillStyle = color;
                    buildCtx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                }
            }
            // Draw selection rectangle if it exists
            drawSelectionRect();
        }

        // Draws the current selection rectangle on the buildCanvas
        function drawSelectionRect() {
            if (currentSelectionRect) {
                const { x1, y1, x2, y2 } = currentSelectionRect;
                buildCtx.strokeStyle = '#FFFFFF'; // White border for selection
                buildCtx.lineWidth = 2;
                buildCtx.setLineDash([5, 5]); // Dashed line
                buildCtx.strokeRect(x1 * BLOCK_SIZE, y1 * BLOCK_SIZE, (x2 - x1 + 1) * BLOCK_SIZE, (y2 - y1 + 1) * BLOCK_SIZE);
                buildCtx.setLineDash([]); // Reset line dash
            }
        }

        // Handles player movement based on arrow keys or touch controls
        function movePlayer(dx, dy) {
            if (gameWon) return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check boundaries
            if (newX < 0 || newX >= MAZE_WIDTH || newY < 0 || newY >= MAZE_HEIGHT) {
                return; // Out of bounds
            }

            const targetBlock = mazeGrid[newY][newX];
            const targetBlockType = typeof targetBlock === 'object' ? targetBlock.type : targetBlock;

            // Handle Push Block
            if (targetBlockType === BLOCK_TYPES.PUSH_BLOCK) {
                const pushToX = newX + dx;
                const pushToY = newY + dy;

                // Check if the spot to push to is within bounds and is a PATH
                if (pushToX >= 0 && pushToX < MAZE_WIDTH &&
                    pushToY >= 0 && pushToY < MAZE_HEIGHT &&
                    (mazeGrid[pushToY][pushToX] === BLOCK_TYPES.PATH || (typeof mazeGrid[pushToY][pushToX] === 'object' && mazeGrid[pushToY][pushToX].type === BLOCK_TYPES.PATH))) {
                    
                    // Move the push block
                    mazeGrid[pushToY][pushToX] = { type: BLOCK_TYPES.PUSH_BLOCK }; // Ensure it's stored as an object
                    mazeGrid[newY][newX] = BLOCK_TYPES.PATH; // Clear old push block position
                    
                    // Move player
                    player.x = newX;
                    player.y = newY;
                    drawGame();
                    checkWinCondition();
                    return; // Movement handled
                } else {
                    // Cannot push, treat as a wall for player movement
                    return;
                }
            }

            // Cannot move onto a wall
            if (targetBlockType === BLOCK_TYPES.WALL) {
                return;
            }

            // Move player
            player.x = newX;
            player.y = newY;
            drawGame();
            checkWinCondition();

            // Handle Trigger block after player moves onto it
            if (targetBlockType === BLOCK_TYPES.TRIGGER) {
                if (typeof targetBlock === 'object' && targetBlock.targetX !== undefined && targetBlock.targetY !== undefined) {
                    const tx = targetBlock.targetX;
                    const ty = targetBlock.targetY;
                    const targetChangeType = targetBlock.targetType || BLOCK_TYPES.PATH; // Default to path if not specified

                    if (mazeGrid[ty] && mazeGrid[ty][tx] !== undefined) {
                        mazeGrid[ty][tx] = targetChangeType; // Change the target block
                        drawGame(); // Redraw to show the change
                        messageBox.textContent = `Trigger activated! Block at (${tx},${ty}) changed.`;
                        setTimeout(() => checkWinCondition(), 1000); // Re-check win condition after message
                    } else {
                        console.warn(`Trigger target invalid: (${tx},${ty})`);
                    }
                } else {
                    console.warn("Trigger block missing target properties.");
                }
            }
        }

        // Checks if the player has reached the end point
        function checkWinCondition() {
            if (player.x === end.x && player.y === end.y) {
                gameWon = true;
                messageBox.textContent = "Congratulations! You reached the end!";
                stopLevelTimerAndSubmitScore(); // New: Submit score on win
                addBrick(); // New: Give player a brick
            } else {
                const modeName = currentGameType.charAt(0).toUpperCase() + currentGameType.slice(1).replace('_', ' ');
                let displayLevelName = currentLevelName;
                if (currentGameType === GAME_MODES.LEVEL && officialPlayableLevels.length > 0) {
                    displayLevelName = officialPlayableLevels[currentLevelIndex].name;
                } else if (currentGameType === GAME_MODES.MAZE) {
                    displayLevelName = "Random Maze";
                } else if (currentGameType === GAME_MODES.BLOCKS) {
                    displayLevelName = "Random Blocks";
                } else if (currentGameType === GAME_MODES.SAVED_LEVEL) {
                    displayLevelName = `Your Level: ${currentLevelName}`;
                } else if (currentGameType === GAME_MODES.COMMUNITY_LEVEL) {
                    displayLevelName = `Community Level: ${currentLevelName}`;
                }
                messageBox.textContent = `Mode: ${modeName} (${displayLevelName}) | Reach the green pad!`;
            }
        }

        // Starts the timer for level completion
        function startLevelTimer() {
            gameStartTime = Date.now();
        }

        // Stops the timer and submits the score to the leaderboard
        async function stopLevelTimerAndSubmitScore() {
            if (!currentLevelId || !window.userId || !window.db) {
                console.warn("Cannot submit score: Missing level ID, user ID, or database instance.");
                messageBox.textContent = "Cannot submit score: Firebase not fully initialized or user not authenticated.";
                return;
            }

            const timeTaken = Date.now() - gameStartTime; // Time in milliseconds

            try {
                const leaderboardRef = collection(window.db, `artifacts/${window.__app_id}/public/data/leaderboard`);
                
                await addDoc(leaderboardRef, {
                    levelId: currentLevelId,
                    levelName: currentLevelName, // Use currentLevelName set during level load
                    playerName: currentPlayerName,
                    userId: window.userId,
                    timeTaken: timeTaken, // Store in milliseconds
                    timestamp: new Date()
                });
                console.log(`Score submitted: ${timeTaken}ms for level ${currentLevelName}`);
                messageBox.textContent += ` Your time: ${formatTime(timeTaken)}!`;
            } catch (e) {
                console.error("Error submitting score:", e);
                messageBox.textContent = `Error submitting score: ${e.message}. Check console for details.`;
            }
        }

        // Formats milliseconds into a readable time string
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = ms % 1000;

            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        }

        // Adds a brick to the player's count
        async function addBrick() {
            if (!window.userId || !window.db) {
                console.warn("Cannot add brick: User ID or database not available.");
                messageBox.textContent = "Cannot add brick: Firebase not fully initialized or user not authenticated.";
                return;
            }

            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                const docSnap = await getDoc(userProfileRef);

                if (docSnap.exists()) {
                    playerBricks = docSnap.data().bricks || 0;
                } else {
                    playerBricks = 0;
                }
                playerBricks++; // Increment brick count
                await setDoc(userProfileRef, { bricks: playerBricks }, { merge: true });
                updateBricksDisplay();
                messageBox.textContent += " You earned a ðŸ§±!";
                console.log(`Player ${currentPlayerName} now has ${playerBricks} bricks.`);
            } catch (e) {
                console.error("Error adding brick:", e);
                messageBox.textContent = `Error adding brick: ${e.message}. Check console for details.`;
            }
        }

        // Fetches player's bricks from Firestore
        async function fetchPlayerBricks() {
            if (!window.userId || !window.db) {
                playerBricks = 0; // Reset if no user/db
                updateBricksDisplay();
                console.warn("Cannot fetch player bricks: Firebase not fully initialized or user not authenticated.");
                return;
            }
            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                const docSnap = await getDoc(userProfileRef);
                if (docSnap.exists()) {
                    playerBricks = docSnap.data().bricks || 0;
                } else {
                    playerBricks = 0;
                }
                updateBricksDisplay();
            } catch (e) {
                console.error("Error fetching player bricks:", e);
                playerBricks = 0; // Default to 0 on error
                updateBricksDisplay();
                messageBox.textContent = `Error fetching bricks: ${e.message}. Check console for details.`;
            }
        }

        // Updates the bricks display in the UI
        function updateBricksDisplay() {
            playerBricksDisplay.textContent = `Bricks: ðŸ§± ${playerBricks}`;
        }

        // Saves customization settings to Firestore
        async function saveCustomization() {
            if (!window.userId || !window.db) {
                console.warn("Cannot save customization: User ID or database not available.");
                return;
            }
            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                await setDoc(userProfileRef, {
                    playerColor: PLAYER_COLOR,
                    wallColor: WALL_COLOR,
                    pathColor: PATH_COLOR
                }, { merge: true });
                console.log("Customization saved successfully!");
            } catch (e) {
                console.error("Error saving customization:", e);
                messageBox.textContent = `Error saving customization: ${e.message}. Check console for details.`;
            }
        }

        // Load user profile (player name, bricks, and customization)
        async function loadUserProfile() {
            if (!window.userId || !window.db) {
                console.warn("Cannot load user profile: User ID or database not available.");
                // Attempt to load player name from localStorage even if Firebase is not ready
                const storedPlayerName = localStorage.getItem('playerName');
                if (storedPlayerName) {
                    currentPlayerName = storedPlayerName;
                    loginButton.textContent = "Logout";
                    loginButton.classList.add('logged-in');
                }
                updateUserIdDisplay();
                updateBricksDisplay();
                drawGame();
                drawBuild();
                return;
            }
            try {
                const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                const docSnap = await getDoc(userProfileRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    currentPlayerName = data.playerName || localStorage.getItem('playerName') || "Anonymous";
                    playerBricks = data.bricks || 0;
                    PLAYER_COLOR = data.playerColor || '#0000FF'; // Default to blue
                    WALL_COLOR = data.wallColor || '#000000';
                    PATH_COLOR = data.pathColor || '#f0f0f0';

                    // Update color pickers to reflect loaded colors
                    playerColorPicker.value = PLAYER_COLOR;
                    wallColorPicker.value = WALL_COLOR;
                    pathColorPicker.value = PATH_COLOR;

                    if (currentPlayerName !== "Anonymous") {
                        loginButton.textContent = "Logout";
                        loginButton.classList.add('logged-in');
                    }
                } else {
                    // If no profile exists in Firestore, check localStorage
                    const storedPlayerName = localStorage.getItem('playerName');
                    if (storedPlayerName) {
                        currentPlayerName = storedPlayerName;
                        loginButton.textContent = "Logout";
                        loginButton.classList.add('logged-in');
                    } else {
                        currentPlayerName = "Anonymous";
                    }
                    playerBricks = 0;
                    // Reset colors to default if no profile exists
                    PLAYER_COLOR = '#0000FF'; // Default to blue
                    WALL_COLOR = '#000000';
                    PATH_COLOR = '#f0f0f0';
                    playerColorPicker.value = PLAYER_COLOR;
                    wallColorPicker.value = WALL_COLOR;
                    pathColorPicker.value = PATH_COLOR;
                }
                updateUserIdDisplay();
                updateBricksDisplay();
                drawGame(); // Redraw game with loaded colors
                drawBuild(); // Redraw build canvas with loaded colors
            } catch (e) {
                console.error("Error loading user profile:", e);
                // Fallback to localStorage and defaults on error
                const storedPlayerName = localStorage.getItem('playerName');
                if (storedPlayerName) {
                    currentPlayerName = storedPlayerName;
                    loginButton.textContent = "Logout";
                    loginButton.classList.add('logged-in');
                } else {
                    currentPlayerName = "Anonymous";
                }
                playerBricks = 0;
                PLAYER_COLOR = '#0000FF'; // Fallback to default blue
                WALL_COLOR = '#000000'; // Fallback to default
                PATH_COLOR = '#f0f0f0'; // Fallback to default
                playerColorPicker.value = PLAYER_COLOR;
                wallColorPicker.value = WALL_COLOR;
                pathColorPicker.value = PATH_COLOR;
                updateUserIdDisplay();
                updateBricksDisplay();
                drawGame();
                drawBuild();
                messageBox.textContent = `Error loading profile: ${e.message}. Check console for details.`;
            }
        }


        // Initializes the game state based on the current mode
        function initializeGame() {
            gameWon = false;
            currentLevelId = null;
            currentLevelName = '';
            
            if (currentGameType === GAME_MODES.LEVEL) {
                if (officialPlayableLevels.length === 0) {
                    messageBox.textContent = "No official levels found. Play a random maze or build your own!";
                    nextLevelButton.style.display = 'none';
                    saveCurrentLevelButton.style.display = 'none'; // Hide save button for official levels
                    mazeCtx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height); // Clear canvas
                    return; // Don't start game if no levels
                }
                loadOfficialLevel(currentLevelIndex); // Now loads from officialPlayableLevels
                saveCurrentLevelButton.style.display = 'none'; // Hide save button for official levels
            } else if (currentGameType === GAME_MODES.MAZE) {
                generateMaze();
                player = getRandomPathPosition();
                do {
                    end = getRandomPathPosition();
                } while (player.x === end.x && player.y === end.y);
                currentLevelId = `random-maze-${Date.now()}`;
                currentLevelName = "Random Maze";
                saveCurrentLevelButton.style.display = 'block'; // Show save button for random modes
            } else if (currentGameType === GAME_MODES.BLOCKS) {
                generateBlocks();
                player = getRandomPathPosition();
                do {
                    end = getRandomPathPosition();
                } while (player.x === end.x && player.y === end.y);
                currentLevelId = `random-blocks-${Date.now()}`;
                currentLevelName = "Random Blocks";
                saveCurrentLevelButton.style.display = 'block'; // Show save button for random modes
            } else if (currentGameType === GAME_MODES.BUILD) {
                if (!buildGrid || buildGrid.length === 0 || buildGrid[0].length === 0) {
                    initBuildGrid();
                }
                buildMessageBox.textContent = "Click to place/remove blocks!";
                updatePlayerAndEndFromBuildGrid();
                saveCurrentLevelButton.style.display = 'none'; // Hide save button in build mode
            } else if (currentGameType === GAME_MODES.SAVED_LEVEL || currentGameType === GAME_MODES.COMMUNITY_LEVEL) {
                // mazeGrid, player, end, currentLevelId, currentLevelName are already set by playSavedLevel/playCommunityLevel
                saveCurrentLevelButton.style.display = 'none'; // Hide save button for saved/community levels
            }
            
            nextLevelButton.style.display = (currentGameType === GAME_MODES.LEVEL && officialPlayableLevels.length > 0) ? 'block' : 'none';

            if (currentGameType !== GAME_MODES.BUILD) {
                startLevelTimer(); // Start timer for playable levels
                checkWinCondition();
                drawGame();
            } else {
                drawBuild();
            }
        }

        // Adjusts canvas size and block size based on container width and window height
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const containerWidth = container.clientWidth - 60;

            BLOCK_SIZE = Math.floor(Math.min(containerWidth / MAZE_WIDTH, (window.innerHeight * 0.6) / MAZE_HEIGHT));
            BLOCK_SIZE = Math.max(BLOCK_SIZE, 8);
            BLOCK_SIZE = Math.min(BLOCK_SIZE, 15);

            mazeCanvas.width = MAZE_WIDTH * BLOCK_SIZE;
            mazeCanvas.height = MAZE_HEIGHT * BLOCK_SIZE;
            buildCanvas.width = MAZE_WIDTH * BLOCK_SIZE;
            buildCanvas.height = MAZE_HEIGHT * BLOCK_SIZE;

            // Redraw content after resizing
            if (startScreen.classList.contains('active')) {
                // No canvas drawing on start screen
            } else if (gamePlayArea.classList.contains('active')) {
                drawGame();
            } else if (buildModeArea.classList.contains('active')) {
                drawBuild();
            }
        }

        // Function to switch between different main screens
        let currentActiveScreen = 'startScreen';
        function showScreen(screenId) {
            startScreen.classList.remove('active');
            gamePlayArea.classList.remove('active');
            buildModeArea.classList.remove('active');
            infoButton.style.display = 'none';
            loginButton.style.display = 'none';

            currentActiveScreen = screenId;

            if (screenId === 'startScreen') {
                startScreen.classList.add('active');
                infoButton.style.display = 'block';
                loginButton.style.display = 'block';
            } else if (screenId === 'gamePlayArea') {
                gamePlayArea.classList.add('active');
                infoButton.style.display = 'block';
                loginButton.style.display = 'block';
                initializeGame();
            } else if (screenId === 'buildModeArea') {
                buildModeArea.classList.add('active');
                infoButton.style.display = 'block';
                loginButton.style.display = 'block';
                initializeGame();
                selectBuildTool(BLOCK_TYPES.WALL); // Default to Wall tool
            }
            resizeCanvas(); // Call resize after showing screen to ensure correct dimensions
        }

        // Handle clicks on the build canvas
        function handleBuildCanvasInteraction(event) {
            const rect = buildCanvas.getBoundingClientRect();
            const scaleX = buildCanvas.width / rect.width;
            const scaleY = buildCanvas.height / rect.height;

            const x = Math.floor((event.clientX - rect.left) * scaleX / BLOCK_SIZE);
            const y = Math.floor((event.clientY - rect.top) * scaleY / BLOCK_SIZE);

            if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) {
                return; // Out of bounds
            }

            if (currentBuildTool === 'selection') {
                if (event.type === 'mousedown') {
                    isDrawing = true;
                    selectionStartPoint = { x, y };
                    selectionEndPoint = { x, y };
                    currentSelectionRect = { x1: x, y1: y, x2: x, y2: y };
                } else if (event.type === 'mousemove' && isDrawing) {
                    selectionEndPoint = { x, y };
                    // Normalize selection rectangle coordinates
                    currentSelectionRect = {
                        x1: Math.min(selectionStartPoint.x, selectionEndPoint.x),
                        y1: Math.min(selectionStartPoint.y, selectionEndPoint.y),
                        x2: Math.max(selectionStartPoint.x, selectionEndPoint.x),
                        y2: Math.max(selectionStartPoint.y, selectionEndPoint.y)
                    };
                    drawBuild(); // Redraw with live selection
                } else if (event.type === 'mouseup') {
                    isDrawing = false;
                    selectionEndPoint = { x, y };
                    currentSelectionRect = {
                        x1: Math.min(selectionStartPoint.x, selectionEndPoint.x),
                        y1: Math.min(selectionStartPoint.y, selectionEndPoint.y),
                        x2: Math.max(selectionStartPoint.x, selectionEndPoint.x),
                        y2: Math.max(selectionStartPoint.y, selectionEndPoint.y)
                    };
                    drawBuild(); // Final redraw with selection
                    buildMessageBox.textContent = `Selected area from (${currentSelectionRect.x1},${currentSelectionRect.y1}) to (${currentSelectionRect.x2},${currentSelectionRect.y2}).`;
                }
            } else { // Handle drawing tools
                // Only proceed if mouse button is down for drawing, or if it's a single click for player/winpad
                if (event.buttons !== 1 && event.type === 'mousemove') return; // Not dragging with left click
                if (event.type === 'mousedown') isDrawing = true;
                if (event.type === 'mouseup') isDrawing = false;
                if (event.type === 'mousemove' && !isDrawing) return;

                let currentBlock = buildGrid[y][x];
                let currentBlockType = typeof currentBlock === 'object' ? currentBlock.type : currentBlock;

                if (currentBuildTool === BLOCK_TYPES.PLAYER_START) {
                    if (event.type === 'mousedown') { // Only place player start on mousedown
                        for (let row = 0; row < MAZE_HEIGHT; row++) {
                            for (let col = 0; col < MAZE_WIDTH; col++) {
                                const block = buildGrid[row][col];
                                if (typeof block === 'object' && block.type === BLOCK_TYPES.PLAYER_START) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH; // Change old player start to path
                                } else if (block === BLOCK_TYPES.PLAYER_START) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH;
                                }
                            }
                        }
                        player = { x, y };
                        buildGrid[y][x] = { type: BLOCK_TYPES.PLAYER_START }; // Store as object for consistency
                        drawBuild();
                    }
                } else if (currentBuildTool === BLOCK_TYPES.WINPAD) {
                    if (event.type === 'mousedown') { // Only place winpad on mousedown
                        for (let row = 0; row < MAZE_HEIGHT; row++) {
                            for (let col = 0; col < MAZE_WIDTH; col++) {
                                const block = buildGrid[row][col];
                                if (typeof block === 'object' && block.type === BLOCK_TYPES.WINPAD) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH; // Change old winpad to path
                                } else if (block === BLOCK_TYPES.WINPAD) {
                                    buildGrid[row][col] = BLOCK_TYPES.PATH;
                                }
                            }
                        }
                        end = { x, y };
                        buildGrid[y][x] = { type: BLOCK_TYPES.WINPAD }; // Store as object for consistency
                        drawBuild();
                    }
                } else if (currentBuildTool === BLOCK_TYPES.TRIGGER) {
                    if (event.type === 'mousedown') { // For trigger, prompt for target coordinates only on mousedown
                        let targetX = parseInt(prompt("Enter target X for trigger (0-" + (MAZE_WIDTH - 1) + "):"));
                        let targetY = parseInt(prompt("Enter target Y for trigger (0-" + (MAZE_HEIGHT - 1) + "):"));
                        if (!isNaN(targetX) && !isNaN(targetY) && targetX >= 0 && targetX < MAZE_WIDTH && targetY >= 0 && targetY < MAZE_HEIGHT) {
                            buildGrid[y][x] = { type: BLOCK_TYPES.TRIGGER, targetX: targetX, targetY: targetY, targetType: BLOCK_TYPES.PATH };
                            buildMessageBox.textContent = `Trigger at (${x},${y}) set to affect (${targetX},${ty}).`;
                            drawBuild();
                        } else {
                            buildMessageBox.textContent = "Invalid target coordinates for trigger.";
                        }
                    }
                } else {
                    // For other blocks (Wall, Path, Moving, Push), and Eraser (which sets to PATH)
                    const targetTool = (currentBuildTool === 'eraser') ? BLOCK_TYPES.PATH : currentBuildTool;

                    // Only change the block if the current block type is different from the target tool
                    if (currentBlockType !== targetTool) {
                        buildGrid[y][x] = targetTool; // Set to current tool
                    }
                    // If player or end was on this spot and it's now PATH, reset their positions
                    if (player.x === x && player.y === y && (buildGrid[y][x] === BLOCK_TYPES.PATH || (typeof buildGrid[y][x] === 'object' && buildGrid[y][x].type === BLOCK_TYPES.PATH))) {
                        player = { x: -1, y: -1 }; // Invalidate player position
                        buildMessageBox.textContent = "Player Start removed! Place a new one.";
                    }
                    if (end.x === x && end.y === y && (buildGrid[y][x] === BLOCK_TYPES.PATH || (typeof buildGrid[y][x] === 'object' && buildGrid[y][x].type === BLOCK_TYPES.PATH))) {
                        end = { x: -1, y: -1 }; // Invalidate end position
                        buildMessageBox.textContent = "Win Pad removed! Place a new one.";
                    }
                    drawBuild();
                }
            }
        }

        // Function to update player and end positions based on buildGrid (e.g., after loading)
        function updatePlayerAndEndFromBuildGrid() {
            let foundPlayer = false;
            let foundEnd = false;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    const block = buildGrid[y][x];
                    const blockType = typeof block === 'object' ? block.type : block;

                    if (blockType === BLOCK_TYPES.PLAYER_START) {
                        player = { x, y };
                        foundPlayer = true;
                    } else if (blockType === BLOCK_TYPES.WINPAD) {
                        end = { x, y };
                        foundEnd = true;
                    }
                }
            }
            if (!foundPlayer) player = { x: -1, y: -1 };
            if (!foundEnd) end = { x: -1, y: -1 };
        }

        // Function to set the active build tool
        function selectBuildTool(toolType) {
            // Remove active-tool class from all buttons
            document.querySelectorAll('.build-tools button').forEach(btn => {
                btn.classList.remove('active-tool');
            });

            // Update currentBuildTool and lastSelectedDrawingTool
            if (toolType === 'selection') { // Special case for selection mode
                currentBuildTool = 'selection'; // Use a string to represent selection mode
                buildMessageBox.textContent = "Tool: Selection. Click and drag to select an area.";
                // Show selection action buttons, hide drawing tools
                selectionActionsContainer.style.display = 'flex';
                drawingToolsContainer.style.display = 'none';
                clearSelection(); // Clear any existing selection when entering selection mode
            } else { // It's a drawing block type
                currentBuildTool = toolType;
                lastSelectedDrawingTool = toolType; // Store the actual block type
                buildMessageBox.textContent = `Tool: ${Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === toolType).replace('_', ' ')}`;
                // Hide selection action buttons, show drawing tools
                selectionActionsContainer.style.display = 'none';
                drawingToolsContainer.style.display = 'flex';
                clearSelection(); // Clear any existing selection when switching to drawing mode
            }

            // Highlight the active tool button
            switch (currentBuildTool) {
                case BLOCK_TYPES.WALL: toolWall.classList.add('active-tool'); break;
                case 'eraser': toolEraser.classList.add('active-tool'); break; // Highlight eraser
                case BLOCK_TYPES.PATH: toolPath.classList.add('active-tool'); break;
                case BLOCK_TYPES.PLAYER_START: toolPlayer.classList.add('active-tool'); break;
                case BLOCK_TYPES.WINPAD: toolWinpad.classList.add('active-tool'); break;
                case BLOCK_TYPES.TRIGGER: toolTrigger.classList.add('active-tool'); break;
                case BLOCK_TYPES.MOVING_BLOCK: toolMovingBlock.classList.add('active-tool'); break;
                case BLOCK_TYPES.PUSH_BLOCK: toolPushBlock.classList.add('active-tool'); break;
                case 'selection': toolSelection.classList.add('active-tool'); break; // Highlight selection button
            }
        }

        // Fills the current selection with a specified block type
        function fillSelection(fillType) {
            if (!currentSelectionRect) {
                buildMessageBox.textContent = "No area selected to fill.";
                return;
            }

            const { x1, y1, x2, y2 } = currentSelectionRect;
            for (let y = y1; y <= y2; y++) {
                for (let x = x1; x <= x2; x++) {
                    // Handle player/winpad replacement
                    if (player.x === x && player.y === y && fillType !== BLOCK_TYPES.PLAYER_START) {
                        player = { x: -1, y: -1 }; // Invalidate player position
                        buildMessageBox.textContent = "Player Start removed! Place a new one.";
                    }
                    if (end.x === x && end.y === y && fillType !== BLOCK_TYPES.WINPAD) {
                        end = { x: -1, y: -1 }; // Invalidate end position
                        buildMessageBox.textContent = "Win Pad removed! Place a new one.";
                    }
                    buildGrid[y][x] = fillType;
                }
            }
            drawBuild();
            buildMessageBox.textContent = `Selected area filled with ${Object.keys(BLOCK_TYPES).find(key => BLOCK_TYPES[key] === fillType).replace('_', ' ')}.`;
            clearSelection(); // Clear selection after filling
        }

        // Clears the current selection (fills with PATH)
        function clearSelection() {
            selectionStartPoint = null;
            selectionEndPoint = null;
            currentSelectionRect = null;
            drawBuild(); // Redraw to remove selection rectangle
            buildMessageBox.textContent = "Selection cleared.";
        }


        // Functions to show/hide modals
        function showModal(modalOverlay) {
            modalOverlay.classList.add('show');
        }

        function hideModal(modalOverlay) {
            modalOverlay.classList.remove('show');
        }

        function hideAllModals() {
            hideModal(infoModalOverlay);
            hideModal(customizationModalOverlay);
            hideModal(menuModalOverlay);
            hideModal(loginModalOverlay);
            hideModal(communityLevelsModalOverlay);
            hideModal(leaderboardModalOverlay);
        }

        // --- Simulated Login Functions ---
        async function handleLogin() {
            const playerName = playerNameInput.value.trim();
            const password = passwordInput.value.trim(); // Password is not used for auth, just for input field

            // Validation checks
            if (playerName.length < 3) {
                messageBox.textContent = "Player Name must be at least 3 characters long.";
                setTimeout(() => messageBox.textContent = "", 3000);
                return;
            }

            if (password.length < 6) {
                messageBox.textContent = "Password must be at least 6 characters long.";
                setTimeout(() => messageBox.textContent = "", 3000);
                return;
            }

            if (playerName) {
                currentPlayerName = playerName;
                localStorage.setItem('playerName', currentPlayerName); // Save player name to localStorage
                loginButton.textContent = "Logout";
                loginButton.classList.add('logged-in');
                updateUserIdDisplay();
                hideModal(loginModalOverlay);
                loadMyLevels(); // Refresh levels for the "logged in" user
                fetchPlayerBricks(); // Fetch bricks on login

                // Save player name to Firestore profile
                if (window.userId && window.db) {
                    try {
                        const userProfileRef = doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/profile/data`);
                        await setDoc(userProfileRef, { playerName: currentPlayerName }, { merge: true });
                        console.log("Player name saved to profile.");
                    } catch (e) {
                        console.error("Error saving player name to profile:", e);
                        messageBox.textContent = `Error saving player name: ${e.message}. Check console for details.`;
                    }
                }

            } else {
                // This else block might be redundant due to the new validation, but kept for safety.
                messageBox.textContent = "Please enter a player name.";
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
            }
        }

        function handleLogout() {
            currentPlayerName = "Anonymous";
            localStorage.removeItem('playerName'); // Remove player name from localStorage
            loginButton.textContent = "Login";
            loginButton.classList.remove('logged-in');
            updateUserIdDisplay();
            myLevelsList.innerHTML = "<div>No levels loaded.</div>"; // Clear levels on logout
            playerBricks = 0; // Reset bricks on logout
            updateBricksDisplay();
        }

        function updateUserIdDisplay() {
            if (userIdDisplay) { // Added null check
                if (currentPlayerName !== "Anonymous") {
                    userIdDisplay.textContent = `Player: ${currentPlayerName} (ID: ${window.userId})`;
                } else {
                    userIdDisplay.textContent = `User ID: ${window.userId} (Anonymous)`;
                }
            }
        }


        // --- Firebase Firestore Functions ---
        async function saveLevel() {
            if (!window.userId || !window.db) {
                buildMessageBox.textContent = "Error: Firebase not fully initialized or user not authenticated to save level.";
                return;
            }
            if (player.x === -1 || end.x === -1) {
                buildMessageBox.textContent = "Please place both Player Start and Win Pad before saving!";
                return;
            }

            const levelName = prompt("Enter a name for your level:");
            if (!levelName) {
                buildMessageBox.textContent = "Level save cancelled.";
                return;
            }

            let levelOrder = prompt("Enter an optional order number for this level (e.g., 1, 2, 3...). Leave blank if no specific order is needed.");
            levelOrder = levelOrder ? parseInt(levelOrder) : null;

            if (levelOrder !== null && (isNaN(levelOrder) || levelOrder < 1)) {
                buildMessageBox.textContent = "Invalid order number. Please enter a positive integer or leave blank.";
                return;
            }

            try {
                const levelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/levels`);
                await addDoc(levelsCollectionRef, {
                    name: levelName,
                    grid: JSON.stringify(buildGrid), // Convert grid to string for storage
                    playerStart: player,
                    winpadEnd: end,
                    order: levelOrder, // Store the optional order number
                    createdAt: new Date(),
                    creatorName: currentPlayerName // Save creator's simulated name
                });
                buildMessageBox.textContent = `Level "${levelName}" saved successfully!`;
                loadMyLevels(); // Refresh the list of levels
            } catch (e) {
                console.error("Error saving document: ", e);
                buildMessageBox.textContent = `Error saving level: ${e.message}. See console for details.`;
            }
        }

        async function publishLevel() {
            if (!window.userId || !window.db) {
                buildMessageBox.textContent = "Error: Firebase not fully initialized or user not authenticated to publish level.";
                return;
            }
            if (player.x === -1 || end.x === -1) {
                buildMessageBox.textContent = "Please place both Player Start and Win Pad before publishing!";
                return;
            }

            const levelName = prompt("Enter a name for your public level:");
            if (!levelName) {
                buildMessageBox.textContent = "Level publish cancelled.";
                return;
            }

            try {
                const publicLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/levels`);
                await addDoc(publicLevelsCollectionRef, {
                    name: levelName,
                    grid: JSON.stringify(buildGrid),
                    playerStart: player,
                    winpadEnd: end,
                    createdAt: new Date(),
                    creatorName: currentPlayerName,
                    creatorId: window.userId,
                    isDailyLevel: false // Default to not a daily level
                });
                buildMessageBox.textContent = `Level "${levelName}" published successfully!`;
            } catch (e) {
                console.error("Error publishing document: ", e);
                buildMessageBox.textContent = `Error publishing level: ${e.message}. See console for details.`;
            }
        }

        async function loadMyLevels() {
            if (!window.userId || !window.db) {
                myLevelsList.innerHTML = "<div>Please log in to see your levels.</div>";
                console.warn("Cannot load my levels: Firebase not fully initialized or user not authenticated.");
                return;
            }

            myLevelsList.innerHTML = "<div>Loading levels...</div>";
            try {
                const levelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/users/${window.userId}/levels`);
                const q = query(levelsCollectionRef); // No orderBy here to avoid index issues, sort in memory
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    myLevelsList.innerHTML = "<div>No levels saved yet.</div>";
                    return;
                }

                const myLevels = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    myLevels.push({ id: doc.id, ...data });
                });

                // Sort levels: first by existing 'order' (ascending), then by 'createdAt' (oldest first)
                myLevels.sort((a, b) => {
                    if (a.order !== null && b.order !== null) {
                        return a.order - b.order;
                    }
                    if (a.order !== null) return -1; // Levels with order come first
                    if (b.order !== null) return 1;
                    return a.createdAt.toDate() - b.createdAt.toDate(); // Fallback to creation date
                });

                myLevelsList.innerHTML = ''; // Clear previous list
                myLevels.forEach((data) => {
                    const levelDiv = document.createElement('div');
                    const orderDisplay = data.order !== null ? `#${data.order} ` : '';
                    levelDiv.innerHTML = `
                        <span class="level-name">${orderDisplay}${data.name} by ${data.creatorName || 'Anonymous'}</span>
                        <div>
                            <button class="play-level-button" data-level-id="${data.id}" data-level-name="${data.name}" data-level-grid='${data.grid}' data-player-start='${JSON.stringify(data.playerStart)}' data-winpad-end='${JSON.stringify(data.winpadEnd)}'>Play</button>
                            <button class="delete-level-button" data-level-id="${data.id}">Delete</button>
                            ${currentPlayerName === 'LtpMer' ? `<button class="set-official-button" data-level-id="${data.id}" data-level-name="${data.name}" data-level-grid='${data.grid}' data-player-start='${JSON.stringify(data.playerStart)}' data-winpad-end='${JSON.stringify(data.winpadEnd)}' data-creator-name="${data.creatorName}" data-creator-id="${data.creatorId}">Set as Official</button>` : ''}
                        </div>
                    `;
                    myLevelsList.appendChild(levelDiv);
                });

                // Add event listeners to the dynamically created buttons
                myLevelsList.querySelectorAll('.play-level-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const levelData = {
                            id: e.target.dataset.levelId,
                            name: e.target.dataset.levelName,
                            grid: JSON.parse(e.target.dataset.levelGrid),
                            playerStart: JSON.parse(e.target.dataset.playerStart),
                            winpadEnd: JSON.parse(e.target.dataset.winpadEnd)
                        };
                        playSavedLevel(levelData);
                    });
                });

                myLevelsList.querySelectorAll('.delete-level-button').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const levelId = e.target.dataset.levelId;
                        // Replaced confirm with a custom message box or modal if available
                        if (window.confirm("Are you sure you want to delete this level?")) {
                            try {
                                // Admin override: LtpMer can delete any level, otherwise only own levels
                                if (currentPlayerName === 'LtpMer') {
                                    // Try to delete from public levels first if it exists there
                                    const publicLevelRef = doc(window.db, `artifacts/${window.__app_id}/public/data/levels`, levelId);
                                    const publicDocSnap = await getDoc(publicLevelRef);
                                    if (publicDocSnap.exists()) {
                                        await deleteDoc(publicLevelRef);
                                        console.log(`Admin (LtpMer) deleted public level: ${levelId}`);
                                    }
                                    // Also try to delete from official levels if it exists there
                                    // Note: Official levels are named 'level-ORDER_NUMBER', not by their original ID.
                                    // We need to find the official level by its content ID
                                    const officialLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/official_levels`);
                                    const qOfficial = query(officialLevelsCollectionRef, where("id", "==", levelId));
                                    const officialSnapshot = await getDocs(qOfficial);
                                    officialSnapshot.forEach(async (officialDoc) => {
                                        await deleteDoc(doc(officialLevelsCollectionRef, officialDoc.id));
                                        console.log(`Admin (LtpMer) deleted official level document: ${officialDoc.id}`);
                                    });
                                    fetchOfficialPlayableLevels(); // Refresh official levels after deletion
                                }
                                // Always delete from user's private levels
                                await deleteDoc(doc(window.db, `artifacts/${window.__app_id}/users/${window.userId}/levels`, levelId));
                                messageBox.textContent = "Level deleted successfully!";
                                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
                                loadMyLevels(); // Refresh the list
                            } catch (error) {
                                console.error("Error deleting level:", error);
                                messageBox.textContent = `Error deleting level: ${error.message}. See console.`;
                                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
                            }
                        }
                    });
                });

                // New: Add event listener for "Set as Official" button
                myLevelsList.querySelectorAll('.set-official-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const levelData = {
                            id: e.target.dataset.levelId,
                            name: e.target.dataset.levelName,
                            grid: e.target.dataset.levelGrid, // Keep as string for direct storage
                            playerStart: JSON.parse(e.target.dataset.playerStart),
                            winpadEnd: JSON.parse(e.target.dataset.winpadEnd),
                            creatorName: e.target.dataset.creatorName,
                            creatorId: e.target.dataset.creatorId
                        };
                        setOfficialLevel(levelData);
                    });
                });

            } catch (e) {
                console.error("Error loading documents: ", e);
                myLevelsList.innerHTML = `<div>Error loading levels: ${e.message}.</div>`;
            }
        }

        async function loadCommunityLevels() {
            if (!window.userId || !window.db) {
                communityLevelsList.innerHTML = "<div>Please log in to see community levels.</div>";
                console.warn("Cannot load community levels: Firebase not fully initialized or user not authenticated.");
                return;
            }

            communityLevelsList.innerHTML = "<div>Loading community levels...</div>";
            try {
                const publicLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/levels`);
                const q = query(publicLevelsCollectionRef);
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    communityLevelsList.innerHTML = "<div>No community levels found. Be the first to publish one!</div>";
                    return;
                }

                communityLevelsList.innerHTML = ''; // Clear previous list
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const levelId = doc.id;
                    const levelDiv = document.createElement('div');
                    levelDiv.innerHTML = `
                        <span class="level-name">${data.name} by ${data.creatorName || 'Anonymous'}</span>
                        <div>
                            <button class="play-level-button" data-level-id="${levelId}" data-level-name="${data.name}" data-level-grid='${data.grid}' data-player-start='${JSON.stringify(data.playerStart)}' data-winpad-end='${JSON.stringify(data.winpadEnd)}'>Play</button>
                            ${currentPlayerName === 'LtpMer' ? `<button class="set-daily-button" data-level-id="${levelId}">Set as Daily</button>` : ''}
                        </div>
                    `;
                    communityLevelsList.appendChild(levelDiv);
                });

                // Add event listeners to the dynamically created buttons
                communityLevelsList.querySelectorAll('.play-level-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const levelData = {
                            id: e.target.dataset.levelId,
                            name: e.target.dataset.levelName,
                            grid: JSON.parse(e.target.dataset.levelGrid),
                            playerStart: JSON.parse(e.target.dataset.playerStart),
                            winpadEnd: JSON.parse(e.target.dataset.winpadEnd)
                        };
                        playCommunityLevel(levelData);
                    });
                });

                communityLevelsList.querySelectorAll('.set-daily-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const levelId = e.target.dataset.levelId;
                        setDailyLevel(levelId);
                    });
                });

            } catch (e) {
                console.error("Error loading community documents: ", e);
                communityLevelsList.innerHTML = `<div>Error loading community levels: ${e.message}.</div>`;
            }
        }

        async function fetchDailyLevel() {
            dailyLevelContainer.style.display = 'none'; // Hide by default
            dailyLevelName.textContent = 'Loading daily level...';
            playDailyLevelButton.onclick = null; // Clear previous handler

            if (!window.db) {
                dailyLevelName.textContent = "Firebase not initialized. Cannot fetch daily level.";
                dailyLevelContainer.style.display = 'block';
                console.warn("Cannot fetch daily level: Firebase database not available.");
                return;
            }

            try {
                const publicLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/levels`);
                const q = query(publicLevelsCollectionRef, where("isDailyLevel", "==", true));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const dailyDoc = querySnapshot.docs[0];
                    const data = dailyDoc.data();
                    currentDailyLevel = {
                        id: dailyDoc.id,
                        name: data.name,
                        grid: JSON.parse(data.grid),
                        playerStart: data.playerStart,
                        winpadEnd: data.winpadEnd
                    };
                    dailyLevelName.textContent = `${currentDailyLevel.name} by ${data.creatorName || 'Anonymous'}`;
                    playDailyLevelButton.onclick = () => playCommunityLevel(currentDailyLevel);
                    dailyLevelContainer.style.display = 'block';
                } else {
                    dailyLevelName.textContent = "No daily level set yet.";
                    dailyLevelContainer.style.display = 'block';
                }
            } catch (e) {
                console.error("Error fetching daily level:", e);
                dailyLevelName.textContent = `Error loading daily level: ${e.message}.`;
                dailyLevelContainer.style.display = 'block';
            }
        }

        async function setDailyLevel(levelIdToSet) {
            if (currentPlayerName !== 'LtpMer') {
                // Replaced confirm with a custom message box or modal if available
                messageBox.textContent = "Only LtpMer can set daily levels.";
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
                return;
            }
            if (!window.db) {
                messageBox.textContent = "Firebase not initialized. Cannot set daily level.";
                setTimeout(() => messageBox.textContent = "", 3000);
                return;
            }

            // Replaced confirm with a custom message box or modal if available
            if (!window.confirm("Are you sure you want to set this as the daily level? This will unset any current daily level.")) {
                return;
            }

            try {
                const publicLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/levels`);

                // 1. Unset current daily level (if any)
                const currentDailyQuery = query(publicLevelsCollectionRef, where("isDailyLevel", "==", true));
                const currentDailySnapshot = await getDocs(currentDailyQuery);
                currentDailySnapshot.forEach(async (docToUnset) => {
                    await updateDoc(doc(publicLevelsCollectionRef, docToUnset.id), { isDailyLevel: false });
                });

                // 2. Set the new daily level
                await updateDoc(doc(publicLevelsCollectionRef, levelIdToSet), { isDailyLevel: true });

                // Replaced alert with a custom message box or modal if available
                messageBox.textContent = "Daily level updated successfully!";
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
                loadCommunityLevels(); // Refresh community list to show new daily
                fetchDailyLevel(); // Refresh daily level display on start screen
            } catch (e) {
                console.error("Error setting daily level:", e);
                // Replaced alert with a custom message box or modal if available
                messageBox.textContent = `Error setting daily level: ${e.message}. See console for details.`;
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
            }
        }

        async function setOfficialLevel(levelData) {
            if (currentPlayerName !== 'LtpMer') {
                // Replaced confirm with a custom message box or modal if available
                messageBox.textContent = "Only LtpMer can set official levels.";
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
                return;
            }
            if (!window.db) {
                messageBox.textContent = "Firebase not initialized. Cannot set official level.";
                setTimeout(() => messageBox.textContent = "", 3000);
                return;
            }

            let order = prompt(`Enter an order number for "${levelData.name}" (e.g., 1, 2, 3...). Existing levels with this order will be overwritten.`);
            order = parseInt(order);

            if (isNaN(order) || order < 1) {
                // Replaced confirm with a custom message box or modal if available
                messageBox.textContent = "Invalid order number. Please enter a positive integer.";
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
                return;
            }

            // Replaced confirm with a custom message box or modal if available
            if (!window.confirm(`Are you sure you want to set "${levelData.name}" as official level #${order}?`)) {
                return;
            }

            try {
                const officialLevelsRef = doc(window.db, `artifacts/${window.__app_id}/public/data/official_levels`, `level-${order}`);
                await setDoc(officialLevelsRef, {
                    id: levelData.id, // Original level ID
                    name: levelData.name,
                    grid: levelData.grid, // Already stringified
                    playerStart: levelData.playerStart,
                    winpadEnd: levelData.winpadEnd,
                    creatorName: levelData.creatorName,
                    creatorId: levelData.creatorId,
                    order: order,
                    setAt: new Date()
                });
                // Replaced alert with a custom message box or modal if available
                messageBox.textContent = `Level "${levelData.name}" set as official level #${order} successfully!`;
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
                await fetchOfficialPlayableLevels(); // Refresh the official levels list
            } catch (e) {
                console.error("Error setting official level:", e);
                // Replaced alert with a custom message box or modal if available
                messageBox.textContent = `Error setting official level: ${e.message}. See console for details.`;
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
            }
        }

        async function fetchOfficialPlayableLevels() {
            if (!window.db) {
                officialPlayableLevels = [];
                console.warn("Firestore not available, cannot fetch official levels.");
                return;
            }
            try {
                const officialLevelsCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/official_levels`);
                // Removed orderBy("order") to avoid index issues, will sort in memory
                const q = query(officialLevelsCollectionRef); 
                const querySnapshot = await getDocs(q);

                officialPlayableLevels = [];
                if (!querySnapshot.empty) {
                    querySnapshot.forEach((doc) => {
                        const data = doc.data();
                        officialPlayableLevels.push(data);
                    });
                    // Sort by 'order' in memory after fetching
                    officialPlayableLevels.sort((a, b) => (a.order || Infinity) - (b.order || Infinity));
                    console.log("Official playable levels loaded:", officialPlayableLevels);
                } else {
                    console.log("No official playable levels found in Firestore.");
                }
            } catch (e) {
                console.error("Error fetching official playable levels:", e);
                officialPlayableLevels = []; // Clear on error
                messageBox.textContent = `Error fetching official levels: ${e.message}. Check console for details.`;
            }
        }


        async function loadLeaderboard() {
            if (!window.db) {
                leaderboardList.innerHTML = "<div>Leaderboard not available.</div>";
                console.warn("Cannot load leaderboard: Firebase database not available.");
                return;
            }
            leaderboardList.innerHTML = "<div>Loading leaderboard...</div>";
            try {
                const leaderboardCollectionRef = collection(window.db, `artifacts/${window.__app_id}/public/data/leaderboard`);
                // Removed orderBy("timeTaken") to avoid index issues, will sort in memory
                const q = query(leaderboardCollectionRef, limit(10)); // Still limit to top 10
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    leaderboardList.innerHTML = "<div>No scores yet. Be the first to set one!</div>";
                    return;
                }

                // Sort results by timeTaken in memory
                const sortedScores = querySnapshot.docs.map(doc => doc.data()).sort((a, b) => a.timeTaken - b.timeTaken);

                leaderboardList.innerHTML = ''; // Clear previous list
                let rank = 1;
                sortedScores.forEach((data) => {
                    const entryDiv = document.createElement('div');
                    entryDiv.classList.add('leaderboard-entry');
                    entryDiv.innerHTML = `
                        <span class="rank">${rank}.</span>
                        <span class="player-name">${data.playerName || 'Anonymous'}</span>
                        <span class="level-name-lb">(${data.levelName || 'N/A'})</span>
                        <span class="time">${formatTime(data.timeTaken)}</span>
                    `;
                    leaderboardList.appendChild(entryDiv);
                    rank++;
                });
            }
            catch (e) {
                console.error("Error loading leaderboard:", e);
                leaderboardList.innerHTML = `<div>Error loading leaderboard: ${e.message}.</div>`;
            }
        }


        function playSavedLevel(levelData) {
            // Ensure grid data is handled correctly, it could be a string or array
            mazeGrid = typeof levelData.grid === 'string' ? JSON.parse(levelData.grid) : levelData.grid;
            player = { ...levelData.playerStart }; // Reset player position
            end = levelData.winpadEnd;
            currentGameType = GAME_MODES.SAVED_LEVEL;
            currentLevelId = levelData.id;
            currentLevelName = levelData.name;
            hideAllModals();
            showScreen('gamePlayArea');
        }

        function playCommunityLevel(levelData) {
            // Ensure grid data is handled correctly, it could be a string or array
            mazeGrid = typeof levelData.grid === 'string' ? JSON.parse(levelData.grid) : levelData.grid;
            player = { ...levelData.playerStart }; // Reset player position
            end = levelData.winpadEnd;
            currentGameType = GAME_MODES.COMMUNITY_LEVEL;
            currentLevelId = levelData.id;
            currentLevelName = levelData.name;
            hideAllModals();
            showScreen('gamePlayArea');
        }

        // New function to transfer current maze to build grid and switch to build mode
        function saveCurrentLevel() {
            // Copy mazeGrid to buildGrid
            buildGrid = mazeGrid.map(row => row.map(block => {
                // Ensure block objects are copied by value, not reference
                return typeof block === 'object' ? { ...block } : block;
            }));

            // Update player and end in buildGrid as objects
            if (player.x !== -1 && player.y !== -1) {
                buildGrid[player.y][player.x] = { type: BLOCK_TYPES.PLAYER_START };
            }
            if (end.x !== -1 && end.y !== -1) {
                buildGrid[end.y][end.x] = { type: BLOCK_TYPES.WINPAD };
            }

            hideAllModals();
            showScreen('buildModeArea');
            buildMessageBox.textContent = "Current level loaded into Build Mode. You can now save or modify it!";
        }

        // --- Event Listeners ---

        playButton.addEventListener('click', () => {
            currentGameType = GAME_MODES.LEVEL;
            currentLevelIndex = 0;
            showScreen('gamePlayArea');
        });

        nextLevelButton.addEventListener('click', () => {
            currentLevelIndex = (currentLevelIndex + 1) % officialPlayableLevels.length;
            initializeGame();
        });

        saveCurrentLevelButton.addEventListener('click', saveCurrentLevel); // Event listener for new button

        infoButton.addEventListener('click', () => showModal(infoModalOverlay));
        closeInfoModalButton.addEventListener('click', () => hideModal(infoModalOverlay));
        infoModalOverlay.addEventListener('click', (e) => {
            if (e.target === infoModalOverlay) {
                hideModal(infoModalOverlay);
            }
        });

        customizationButtonStart.addEventListener('click', () => showModal(customizationModalOverlay));
        closeCustomizationModalButton.addEventListener('click', () => {
            hideModal(customizationModalOverlay);
            saveCustomization(); // Save customization when closing the modal
        });
        customizationModalOverlay.addEventListener('click', (e) => {
            if (e.target === customizationModalOverlay) {
                hideModal(customizationModalOverlay);
                saveCustomization(); // Save customization when clicking outside the modal
            }
        });

        playerColorPicker.addEventListener('input', (e) => { PLAYER_COLOR = e.target.value; drawGame(); drawBuild(); saveCustomization(); });
        wallColorPicker.addEventListener('input', (e) => { WALL_COLOR = e.target.value; drawGame(); drawBuild(); saveCustomization(); });
        pathColorPicker.addEventListener('input', (e) => { PATH_COLOR = e.target.value; drawGame(); drawBuild(); saveCustomization(); });

        menuButtonStart.addEventListener('click', () => {
            showModal(menuModalOverlay);
            loadMyLevels();
            updateUserIdDisplay();
            fetchPlayerBricks();
        });
        closeMenuModalButton.addEventListener('click', () => hideModal(menuModalOverlay));
        menuModalOverlay.addEventListener('click', (e) => {
            if (e.target === menuModalOverlay) {
                hideModal(menuModalOverlay);
            }
        });

        startRandomMazeButton.addEventListener('click', () => {
            currentGameType = GAME_MODES.MAZE;
            hideAllModals();
            showScreen('gamePlayArea');
        });

        startRandomBlocksButton.addEventListener('click', () => {
            currentGameType = GAME_MODES.BLOCKS;
            hideAllModals();
            showScreen('gamePlayArea');
        });

        buildModeButton.addEventListener('click', () => {
            currentGameType = GAME_MODES.BUILD;
            hideAllModals();
            showScreen('buildModeArea');
        });

        refreshMyLevelsButton.addEventListener('click', loadMyLevels);

        // Community Levels button in Menu
        searchLevelsButton.addEventListener('click', () => {
            showModal(communityLevelsModalOverlay);
            loadCommunityLevels();
        });
        refreshCommunityLevelsButton.addEventListener('click', loadCommunityLevels);
        closeCommunityLevelsModalButton.addEventListener('click', () => hideModal(communityLevelsModalOverlay));
        communityLevelsModalOverlay.addEventListener('click', (e) => {
            if (e.target === communityLevelsModalOverlay) {
                hideModal(communityLevelsModalOverlay);
            }
        });

        // Leaderboard event listeners
        leaderboardButton.addEventListener('click', () => {
            showModal(leaderboardModalOverlay);
            loadLeaderboard();
        });
        refreshLeaderboardButton.addEventListener('click', loadLeaderboard);
        closeLeaderboardModalButton.addEventListener('click', () => hideModal(leaderboardModalOverlay));
        leaderboardModalOverlay.addEventListener('click', (e) => {
            if (e.target === leaderboardModalOverlay) {
                hideModal(leaderboardModalOverlay);
            }
        });


        // Build Mode specific buttons and tools
        clearBuildGridButton.addEventListener('click', () => {
            initBuildGrid();
            drawBuild();
            buildMessageBox.textContent = "Grid cleared! Start building!";
        });

        saveLevelButton.addEventListener('click', saveLevel);
        publishLevelButton.addEventListener('click', publishLevel);

        // Tool selection event listeners
        toolEraser.addEventListener('click', () => selectBuildTool('eraser')); // Eraser tool sets currentBuildTool to 'eraser' string
        toolWall.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.WALL));
        toolPath.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.PATH));
        toolPlayer.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.PLAYER_START));
        toolWinpad.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.WINPAD));
        toolTrigger.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.TRIGGER));
        toolMovingBlock.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.MOVING_BLOCK));
        toolPushBlock.addEventListener('click', () => selectBuildTool(BLOCK_TYPES.PUSH_BLOCK));
        toolSelection.addEventListener('click', () => selectBuildTool('selection')); // Selection tool sets currentBuildTool to 'selection' string

        // Selection action buttons
        fillSelectionButton.addEventListener('click', () => {
            if (lastSelectedDrawingTool !== 'selection') { // Ensure it's a valid block type
                fillSelection(lastSelectedDrawingTool);
            } else {
                buildMessageBox.textContent = "Please select a drawing tool first (e.g., Wall, Player) to fill the selection.";
            }
        });
        clearSelectionButton.addEventListener('click', () => fillSelection(BLOCK_TYPES.PATH)); // Clear selection always fills with PATH
        exitSelectionButton.addEventListener('click', () => selectBuildTool(lastSelectedDrawingTool)); // New: Exit selection and go back to last drawing tool

        backToMainMenuButtonGame.addEventListener('click', () => showScreen('startScreen'));
        backToMainMenuButtonBuild.addEventListener('click', () => showScreen('startScreen'));

        window.addEventListener('resize', resizeCanvas);

        // Initial setup when the window loads
        window.onload = () => {
            // Immediately show the start screen and resize the canvas
            showScreen('startScreen');
            resizeCanvas();
            
            // Listen for Firebase auth readiness and then load user data and levels
            document.addEventListener('firebaseAuthReady', async () => {
                await loadUserProfile(); // Load user profile and customization first
                await fetchOfficialPlayableLevels(); // Fetch official levels after auth
                fetchDailyLevel(); // Fetch daily level after auth
            });
            // If firebaseAuthReady event already fired before onload, manually trigger
            if (window.userId) {
                loadUserProfile();
                fetchOfficialPlayableLevels();
                fetchDailyLevel();
            }
        };

        loginButton.addEventListener('click', () => {
            if (loginButton.classList.contains('logged-in')) {
                handleLogout();
            } else {
                showModal(loginModalOverlay);
            }
        });
        loginSubmitButton.addEventListener('click', handleLogin);
        loginCancelButton.addEventListener('click', () => hideModal(loginModalOverlay));
        loginModalOverlay.addEventListener('click', (e) => {
            if (e.target === loginModalOverlay) {
                hideModal(loginModalOverlay);
            }
        });

        // Event listener for daily level play button
        playDailyLevelButton.addEventListener('click', () => {
            if (currentDailyLevel) {
                playCommunityLevel(currentDailyLevel);
            } else {
                messageBox.textContent = "No daily level is currently set.";
                setTimeout(() => messageBox.textContent = "", 3000); // Clear message after 3 seconds
            }
        });

        // Build canvas drawing event listeners
        buildCanvas.addEventListener('mousedown', handleBuildCanvasInteraction);
        buildCanvas.addEventListener('mouseup', handleBuildCanvasInteraction);
        buildCanvas.addEventListener('mousemove', handleBuildCanvasInteraction);
        // Prevent context menu on right click for better drawing experience
        buildCanvas.addEventListener('contextmenu', (e) => e.preventDefault());


        // Keyboard controls for player movement
        window.addEventListener('keydown', (e) => {
            if (currentActiveScreen === 'gamePlayArea') {
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        movePlayer(0, -1);
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        movePlayer(-1, 0);
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        movePlayer(1, 0);
                        break;
                    case 'Escape':
                        hideAllModals();
                        break;
                }
            } else {
                if (e.key === 'Escape') {
                    hideAllModals();
                }
            }
        });

        // Touch controls for player movement
        touchControls.addEventListener('click', (e) => {
            if (currentActiveScreen !== 'gamePlayArea') return;

            const button = e.target.closest('.touch-button');
            if (!button) return;

            const direction = button.dataset.direction;
            switch (direction) {
                case 'up':
                    movePlayer(0, -1);
                    break;
                case 'down':
                    movePlayer(0, 1);
                    break;
                case 'left':
                    movePlayer(-1, 0);
                    break;
                case 'right':
                    movePlayer(1, 0);
                    break;
            }
        });
    </script>
</body>
</html>
